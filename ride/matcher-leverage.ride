{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "matcher-leverage.ride"
let WAVES = "WAVES"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

let kFactoryAddress      = ["%s", "factoryAddress"].makeString(SEP)
let factoryAddressString = this.getString(kFactoryAddress).valueOrErrorMessage("factory address is not set")
let factoryAddress       = factoryAddressString.addressFromString().valueOrErrorMessage("invalid factory address")

let kForceStop = ["%s", "forceStop"].makeString(SEP)
let forceStop  = factoryAddress.getBoolean(kForceStop).valueOrElse(false)

let kValidatorAddress = ["%s", "validatorAddress"].makeString(SEP)
let validatorAddress  = factoryAddress.getString(kValidatorAddress).valueOrElse("")
let kTreasuryAddress  = ["%s", "treasuryAddress"].makeString(SEP)
let sTreasuryAddress  = factoryAddress.getString(kTreasuryAddress).valueOrElse("")
let treasuryAddress   = sTreasuryAddress.addressFromStringValue()

let kMatcherPublicKey = ["%s", "matcherPublicKey"].makeString(SEP)
let matcherPublicKey  = factoryAddress.getString(kMatcherPublicKey).valueOrElse("").fromBase58String()
let matcherAddress    = matcherPublicKey.addressFromPublicKey()
let sMatcherAddress   = matcherAddress.toString()

func kUserBalance(user: String, assetId: String) = ["%s%s%s", "balance", user, assetId].makeString(SEP)
func getUserBalance(user: String, assetId: String) = treasuryAddress.getInteger(kUserBalance(user, assetId)).valueOrElse(0)

func kUserLoan(user: String, assetId: String) = ["%s%s%s", "loan", user, assetId].makeString(SEP)
func getUserLoan(user: String, assetId: String) = treasuryAddress.getInteger(kUserLoan(user, assetId)).valueOrElse(0)

func kUserLeverage(user: String) = ["%s%s", "leverage", user].makeString(SEP)
func getUserLeverage(user: String) = factoryAddress.getInteger(kUserLeverage(user)).valueOrElse(1)

func padBytes(x: ByteVector) = {
  let a = 0.toBytes()
  a + a.drop(x.size()) + x
}

func bytesToInt(x: ByteVector) = {
  x.padBytes().toBigInt().toInt()
}

func parseOrderFlags(flags: ByteVector) = {
  let loanPaymentFlag = flags.takeRight(1).bytesToInt()
  let isLoanPayment = (loanPaymentFlag == 1)

  (isLoanPayment)
}

func calcUserAmountFromLeverage(totalAmount: Int, leverage: Int) = {
  if (leverage <= 1) 
    then totalAmount
    else fraction(totalAmount, 1, leverage)
}

func calcLoanAmountFromLeverage(totalAmount: Int, leverage: Int) = {
  totalAmount - calcUserAmountFromLeverage(totalAmount, leverage)
}

@Callable(i)
func init(matcherFactory: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [StringEntry(kFactoryAddress, matcherFactory)]
}

@Callable(i)
func exchange(
  makerAddress   : String,
  makerSendAsset : String,
  makerSendAmount: Int,
  makerGetAsset  : String,
  makerGetAmount : Int,
  makerFlags     : ByteVector,
  makerFeeAsset  : String,
  makerFeeAmount : Int,
  takerAddress   : String,
  takerSendAsset : String,
  takerSendAmount: Int,
  takerGetAsset  : String,
  takerGetAmount : Int,
  takerFlags     : ByteVector,
  takerFeeAsset  : String,
  takerFeeAmount : Int
) = {
  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    i.caller.toString() == validatorAddress || throwErr("permission denied"),
    makerAddress != takerAddress || throwErr("maker and taker is the same")
  ]

  ### Maker actions
  # Check if can borrow send asset
  let (isMakerLoanPayment, makerLeverage) = (parseOrderFlags(makerFlags), getUserLeverage(makerAddress))
  let makerNewLoanAmount = calcLoanAmountFromLeverage(makerSendAmount, makerLeverage)
  let makerLoanBorrowAction = if (makerNewLoanAmount > 0) 
    then [ treasuryAddress.invoke("loanBorrowFor", [makerAddress, makerSendAsset, makerNewLoanAmount], []) ]
    else []

  # Check if can repay get asset
  let makerGetAssetCurrentLoan = getUserLoan(makerAddress, makerGetAsset)
  let makerLoanCover = min([makerGetAmount, makerGetAssetCurrentLoan])
  let makerLoanPaymentAction = if (isMakerLoanPayment && makerLoanCover > 0)
    then [ treasuryAddress.invoke("loanPaymentFor", [makerAddress, makerGetAsset, makerLoanCover], []) ]
    else []

  ### Taker actions
  # Check if can borrow send asset
  let (isTakerLoanPayment, takerLeverage) = (parseOrderFlags(takerFlags), getUserLeverage(takerAddress))
  let takerNewLoanAmount = calcLoanAmountFromLeverage(takerSendAmount, takerLeverage)
  let takerLoanBorrowAction = if (takerNewLoanAmount > 0) 
    then [ treasuryAddress.invoke("loanBorrowFor", [takerAddress, takerSendAsset, takerNewLoanAmount], []) ]
    else []

  # Check if can repay get asset
  let takerGetAssetCurrentLoan = getUserLoan(takerAddress, takerGetAsset)
  let takerLoanCover = min([takerGetAmount, takerGetAssetCurrentLoan])
  let takerLoanPaymentAction = if (isTakerLoanPayment && takerLoanCover > 0)
    then [ treasuryAddress.invoke("loanPaymentFor", [takerAddress, takerGetAsset, takerLoanCover], []) ]
    else []

  # Exchange actions
  let swapActions = [
      treasuryAddress.invoke("subBalance", [makerAddress, makerSendAsset, makerSendAmount], []),
      treasuryAddress.invoke("addBalance", [makerAddress, makerGetAsset, makerGetAmount], []),
      treasuryAddress.invoke("subBalance", [makerAddress, makerFeeAsset, makerFeeAmount], []),

      # Taker state changes
      treasuryAddress.invoke("subBalance", [takerAddress, takerSendAsset, takerSendAmount], []),
      treasuryAddress.invoke("addBalance", [takerAddress, takerGetAsset, takerGetAmount], []),
      treasuryAddress.invoke("subBalance", [takerAddress, takerFeeAsset, takerFeeAmount], []),

      # Transfer fee to Matcher
      treasuryAddress.invoke("transferTo", [sMatcherAddress, makerFeeAsset, makerFeeAmount], []),
      treasuryAddress.invoke("transferTo", [sMatcherAddress, takerFeeAsset, takerFeeAmount], [])
    ]

  # Actions order is important!
  (
    [],
    makerLoanBorrowAction ++
    takerLoanBorrowAction ++
    swapActions ++
    makerLoanPaymentAction ++
    takerLoanPaymentAction
  )
}