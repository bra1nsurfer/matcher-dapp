{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "matcher-spot.ride"
let WAVES = "WAVES"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

let kFactoryAddress      = ["%s", "factoryAddress"].makeString(SEP)
let factoryAddressString = this.getString(kFactoryAddress).valueOrErrorMessage("factory address is not set")
let factoryAddress       = factoryAddressString.addressFromString().valueOrErrorMessage("invalid factory address")

let kForceStop        = ["%s", "forceStop"].makeString(SEP)

let kMatcherValidator = ["%s", "matcherValidator"].makeString(SEP)
let matcherValidator  = factoryAddress.getString(kMatcherValidator).valueOrElse("")

func kUserBalance(user: String, assetId: String) = ["%s%s%s", "balance", user, assetId].makeString(SEP)

func getUserBalances(user: String, asset1: String, asset2: String) = {
  let asset1Bal = this.getInteger(kUserBalance(user, asset1)).valueOrElse(0)
  let asset2Bal = this.getInteger(kUserBalance(user, asset2)).valueOrElse(0)

  (asset1Bal, asset2Bal)
}

@Callable(i)
func init(matcherFactory: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [StringEntry(kFactoryAddress, matcherFactory)]
}

@Callable(i)
func deposit() = {
  let userAddress = i.caller.toString()

  func a(actionsList: List[IntegerEntry], nextPayment: AttachedPayment) = {
    let kCurAsset = kUserBalance(userAddress, nextPayment.assetId.assetIdToString())
    let curBalance = this.getInteger(kCurAsset).valueOrElse(0)

    actionsList ++ [IntegerEntry(kCurAsset, curBalance + nextPayment.amount)]
  }

  let allActions = FOLD<10>(i.payments, [], a)

  allActions
}

@Callable(i) 
func withdraw(assetId: String, amount: Int) = {
  let kBalance = kUserBalance(i.caller.toString(), assetId)
  let balance = this.getInteger(kBalance).valueOrElse(0)
  let newBalance = balance - amount

  strict check = [
    amount > 0 || throwErr("amount must be greater than 0"),
    newBalance >= 0 || throwErr("not enough balance")
  ]

  [
    ScriptTransfer(i.caller, amount, assetId.stringToAssetId()),
    IntegerEntry(kBalance, newBalance)
  ]
}

@Callable(i)
func exchange(
  buyerAddress : String,
  buyerFeeType : String,
  sellerAddress: String,
  sellerFeeType: String,
  asset1Amount : Int,
  asset1Id     : String,
  asset2Amount : Int,
  asset2Id     : String
  ) = {
  
  let (buyerAsset1Bal, buyerAsset2Bal)   = getUserBalances(buyerAddress, asset1Id, asset2Id)
  let (sellerAsset1Bal, sellerAsset2Bal) = getUserBalances(sellerAddress, asset1Id, asset2Id)

  let newBuyerAsset1Bal = buyerAsset1Bal + asset1Amount
  let newBuyerAsset2Bal = buyerAsset2Bal - asset2Amount

  let newSellerAsset1Bal = sellerAsset1Bal - asset1Amount
  let newSellerAsset2Bal = sellerAsset2Bal + asset2Amount

  strict check = [
    i.caller.toString() == matcherValidator || throwErr("permission denied"),
    buyerAddress != sellerAddress || throwErr("buyer and seller is the same"),
    newBuyerAsset2Bal >= 0 || throwErr(["buyer negative balance", buyerAddress, asset2Id, buyerAsset2Bal.toString(), newBuyerAsset2Bal.toString()].makeString(" ")),
    newSellerAsset1Bal >= 0 || throwErr(["seller negative balance", sellerAddress, asset1Id, sellerAsset1Bal.toString(), newSellerAsset1Bal.toString()].makeString(" "))
  ]

  [
    IntegerEntry(kUserBalance(buyerAddress, asset1Id), newBuyerAsset1Bal),
    IntegerEntry(kUserBalance(buyerAddress, asset2Id), newBuyerAsset2Bal),
    IntegerEntry(kUserBalance(sellerAddress, asset1Id), newSellerAsset1Bal),
    IntegerEntry(kUserBalance(sellerAddress, asset2Id), newSellerAsset2Bal)
  ]
}