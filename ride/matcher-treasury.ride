{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "matcher-treasury.ride"
let WAVES = "WAVES"
let DEC8 = 1_0000_0000

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

func isValidAddress(addressString: String) = {
  match (addressFromString(addressString)) {
    case t:Address => true
    case _ => false
  }
}

let kFactoryAddress      = ["%s", "factoryAddress"].makeString(SEP)
let factoryAddressString = this.getString(kFactoryAddress).valueOrErrorMessage("factory address is not set")
let factoryAddress       = factoryAddressString.addressFromString().valueOrErrorMessage("invalid factory address")

let kForceStop = ["%s", "forceStop"].makeString(SEP)
let forceStop  = factoryAddress.getBoolean(kForceStop).valueOrElse(false)

let kValidatorAddress = ["%s", "validatorAddress"].makeString(SEP)
let validatorAddress  = factoryAddress.getString(kValidatorAddress).valueOrElse("")

let kPoolAddress = ["%s", "poolAddress"].makeString(SEP)
let poolAddress  = factoryAddress.getString(kPoolAddress).valueOrElse("")

let kPredictionAddress = ["%s", "predictionAddress"].makeString(SEP)
let predictionAddress = factoryAddress.getString(kPredictionAddress).valueOrElse("")

func kUserBalance(user: String, assetId: String) = ["%s%s%s", "balance", user, assetId].makeString(SEP)
func getUserBalance(user: String, assetId: String) = this.getInteger(kUserBalance(user, assetId)).valueOrElse(0)

func kUserLoan(user: String, assetId: String) = ["%s%s%s", "loan", user, assetId].makeString(SEP)
func getUserLoan(user: String, assetId: String) = this.getInteger(kUserLoan(user, assetId)).valueOrElse(0)

func kUserLastWithdrawTx(user: String) = ["%s%s", "lastFastWithdrawTx", user].makeString(SEP)
func getUserLastWithdrawTx(user: String) = this.getString(kUserLastWithdrawTx(user)).valueOrElse("")

let kAllowedAssets = ["%s", "allowedAssets"].makeString(SEP)
let allowedAssets  = match (factoryAddress.getString(kAllowedAssets)) {
    case s:String => s.split_4C(SEP)
    case _ => []
}

let kMatcherPublicKey = ["%s", "matcherPublicKey"].makeString(SEP)
let matcherPublicKey  = factoryAddress.getString(kMatcherPublicKey).valueOrElse("").fromBase58String()

let kWithdrawDelay = ["%s", "withdrawDelay"].makeString(SEP)
let withdrawDelay  = factoryAddress.getInteger(kWithdrawDelay).valueOrElse(0)

func kUserWithdraw(user: String, txId: String) = ["%s%s%s", "withdraw", user, txId].makeString(SEP)
func vUserWithdraw(assetId: String, amount: Int, unlockHeight: Int) = 
  ["%s%d%d", assetId, amount.toString(), unlockHeight.toString()].makeString(SEP)
func parseWithdraw(vWithdraw: String) = {
  let x = vWithdraw.split(SEP)
  let (assetId, amount, unlockHeight) = 
    (
      x[1].valueOrErrorMessage("could not get unlock asset id"), 
      x[2].parseInt().valueOrErrorMessage("could not parse unlock amount"), 
      x[3].parseInt().valueOrErrorMessage("could not parse unlock height")
    )

  (assetId, amount, unlockHeight)
}

# TODO: decide which way is better
# let kSpotAddress     = ["%s", "spotAddress"].makeString(SEP)
# let kLeverageAddress = ["%s", "leverageAddress"].makeString(SEP)

# let orderContractList = [
#     factoryAddress.getString(kSpotAddress).valueOrElse(""),     # spot
#     factoryAddress.getString(kLeverageAddress).valueOrElse(""), # leverage
#     ""                                                          # margin
# ]

let orderContractList = {
  let addressStringList = factoryAddress.invoke("getAllOrderTypeContracts", [], [])
  
  match (addressStringList) {
      case s:List[Any] => s
      case _ => []
    }
}

func isUserWithDebt(user: String) = {
  func sumDebt(acc: Int, nextAsset: String) = (acc + getUserLoan(user, nextAsset))
  let debt = FOLD<100>(allowedAssets, 0, sumDebt)

  (debt > 0)
}

func changeBalanceHelper(user: String, assetId: String, amount: Int, add: Boolean, isPrediction: Boolean) = {
  let oldBalance = getUserBalance(user, assetId)
  let newBalance = if add then oldBalance + amount else oldBalance - amount

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    isPrediction || allowedAssets.containsElement(assetId) || ["(balance) asset is not allowed", assetId].makeString(" ").throwErr(),
    amount >= 0 || throwErr("amount must be greater or equal to 0"),
    newBalance >= 0 || throwErr(["not enough balance", user, assetId].makeString(" "))
  ]

  [
    IntegerEntry(kUserBalance(user, assetId), newBalance)
  ]
}

func changeLoanHelper(user: String, assetId: String, amount: Int, add: Boolean) = {
  let oldLoan = getUserLoan(user, assetId)
  let newRawLoan = if add then oldLoan + amount else oldLoan - amount
  let newLoan = max([0, newRawLoan])

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    allowedAssets.containsElement(assetId) || ["(loan) asset is not allowed", assetId].makeString(" ").throwErr(),
    amount > 0 || throwErr("amount must be greater than 0")
  ]

  [
    IntegerEntry(kUserLoan(user, assetId), newLoan)
  ]
}

func getAllUserInfo(user: String) = {
  func helper(acc: List[(String, Int, Int)], nextAsset: String) = {
    let balance = getUserBalance(user, nextAsset)
    let loan = getUserLoan(user, nextAsset)

    acc :+ (nextAsset, balance, loan)
  }

  let info = FOLD<100>(allowedAssets, [], helper)

  info
}

func loanPaymentHelper(user: String, assetId: String, amount: Int) = {
  let pool = poolAddress.addressFromStringValue()
  let userBalance = getUserBalance(user, assetId)

  strict checks = [
    amount <= userBalance || throwErr("not enough balance")
  ]

  strict inv = [
    pool.invoke("loanPayment", [user], [AttachedPayment(assetId.stringToAssetId(), amount)])
  ]

  let balanceActions = changeBalanceHelper(user, assetId, amount, false, false)
  let loanActions = changeLoanHelper(user, assetId, amount, false)

  balanceActions ++ loanActions
}

func loanBorrowHelper(user: String, assetId: String, amount: Int) = {
  let pool = poolAddress.addressFromStringValue()
  strict inv = [
    pool.invoke("loanBorrow", [user, assetId, amount], [])
  ]

  # TODO: Parametrize in future
  # 0.05 from amount (5%)
  let interest = fraction(amount, 500_0000, DEC8)

  let balanceActions = changeBalanceHelper(user, assetId, amount, true, false)
  let loanActions = changeLoanHelper(user, assetId, amount+interest, true)

  balanceActions ++ loanActions
}

func unlockWithdrawHelper(user: String, txId: String, isMatcher: Boolean) = {
  let withdrawKey = kUserWithdraw(user, txId)
  let withdrawValueString = this.getStringValue(withdrawKey)
  let (assetId, amount, unlockHeight) = parseWithdraw(withdrawValueString)

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    isMatcher || height > unlockHeight || throwErr(["withdraw is locked until (" + unlockHeight.toString() + ")"].makeString(""))
  ]

  [
    DeleteEntry(withdrawKey),
    ScriptTransfer(user.addressFromStringValue(), amount, assetId.stringToAssetId())
  ]
}

func withdrawHelper(user: String, assetId: String, amount: Int) = {
  let kBalance = kUserBalance(user, assetId)
  let balance = this.getInteger(kBalance).valueOrElse(0)
  let newBalance = balance - amount

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    amount > 0 || throwErr("amount must be greater than 0"),
    newBalance >= 0 || throwErr(["not enough balance to withdraw", user].makeString(" ")),
    !isUserWithDebt(user) || throwErr("cannot withdraw with debt")
  ]

  (kBalance, newBalance)
}

func depositHelper(userAddress: String, i: Invocation) = {
  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    userAddress.isValidAddress() || throwErr("userAddress is not valid")
  ]

  func a(actionsList: List[IntegerEntry], nextPayment: AttachedPayment) = {
    let assetId = nextPayment.assetId.assetIdToString()
    let kCurAsset = kUserBalance(userAddress, assetId)
    let curBalance = this.getInteger(kCurAsset).valueOrElse(0)

    if (allowedAssets.containsElement(assetId)) 
      then actionsList ++ [IntegerEntry(kCurAsset, curBalance + nextPayment.amount)]
      else throwErr("asset not in the allowed list")
  }

  let allActions = FOLD<10>(i.payments, [], a)

  allActions
}

func getWithdrawMatcherSignData(lastFastWithdrawTx: String, userAddress: String, assetId: String, amount: Int) = {
  let assetIdBytes = match (assetId.stringToAssetId()) {
      case b:ByteVector => b
      case _ => 0.toBytes().take(1)
    }
  # Signer padding 
  # Prefix: [255, 255, 255, 1]
  let prefix = base58'7YXq4t'
  let signData = lastFastWithdrawTx.fromBase58String() + userAddress.fromBase58String() + assetIdBytes + amount.toBytes()
  
  prefix + signData
}

@Callable(i)
func init(matcherFactory: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [StringEntry(kFactoryAddress, matcherFactory)]
}

@Callable(i)
func deposit() = {
  let userAddress = i.caller.toString()

  depositHelper(userAddress, i)
}

@Callable(i)
func depositFor(userAddress: String) = {
  depositHelper(userAddress, i)
}

@Callable(i) 
func userWithdraw(assetId: String, amount: Int) = {
  let user = i.caller.toString()
  let (kBalance, newBalance) = withdrawHelper(user, assetId, amount)

  let key = kUserWithdraw(user, i.transactionId.toBase58String())
  let val = vUserWithdraw(assetId, amount, height+withdrawDelay)

  [
    StringEntry(key, val),
    IntegerEntry(kBalance, newBalance)
  ]
}

@Callable(i)
func fastWithdraw(assetId: String, amount: Int, matcherSignature: String) = {
  let user = i.caller.toString()
  let lastFastWithdrawTx = getUserLastWithdrawTx(user)
  let signData = getWithdrawMatcherSignData(lastFastWithdrawTx, user, assetId, amount)
  let isApproved = sigVerify(signData, matcherSignature.fromBase58String(), matcherPublicKey)

  strict check = [
    lastFastWithdrawTx == "" || isApproved || throwErr("fast withdraw is not approved by matcher")
  ]

  let (kBalance, newBalance) = withdrawHelper(user, assetId, amount)
  
  [
    ScriptTransfer(user.addressFromStringValue(), amount, assetId.stringToAssetId()),
    IntegerEntry(kBalance, newBalance),
    StringEntry(kUserLastWithdrawTx(user), i.transactionId.toBase58String())
  ]
}

@Callable(i) 
func userUnlockWithdraw(txId: String) = {
  unlockWithdrawHelper(i.caller.toString(), txId, false)
}

@Callable(i) 
func matcherUnlockWithdraw(user: String, txId: String) = {
  let isMatcher = (i.callerPublicKey == matcherPublicKey)
  strict check = [
    isMatcher || throwErr("unlock permission denied")
  ]

  unlockWithdrawHelper(user, txId, isMatcher)
}

@Callable(i)
func subBalance(user: String, assetId: String, amount: Int) = {
  let callerAddress = i.caller.toString()
  strict check = [
      orderContractList.containsElement(callerAddress) || throwErr("permission denied")
  ]

  changeBalanceHelper(user, assetId, amount, false, callerAddress == predictionAddress)
}

@Callable(i)
func addBalance(user: String, assetId: String, amount: Int) = {
  let callerAddress = i.caller.toString()
  strict check = [
      orderContractList.containsElement(callerAddress) || throwErr("permission denied")
  ]
  changeBalanceHelper(user, assetId, amount, true, callerAddress == predictionAddress)
}

@Callable(i)
func transferTo(user: String, assetId: String, amount: Int) = {
  strict check = [
      orderContractList.containsElement(i.caller.toString()) || throwErr("permission denied")
  ]
  
  if (amount > 0) then [ScriptTransfer(user.addressFromStringValue(), amount, assetId.stringToAssetId())] else []
}

@Callable(i)
func loanBorrow(assetId: String, amount: Int) = {
  let user = i.caller.toString()

  loanBorrowHelper(user, assetId, amount) 
}

@Callable(i)
func loanBorrowFor(user: String, assetId: String, amount: Int) = {
  strict check = [
      orderContractList.containsElement(i.caller.toString()) || throwErr("permission denied")
  ]
  
  loanBorrowHelper(user, assetId, amount) 
}

@Callable(i)
func loanPayment(assetId: String, amount: Int) = {
  let user = i.caller.toString()

  loanPaymentHelper(user, assetId, amount)
}

@Callable(i)
func loanPaymentFor(user: String, assetId: String, amount: Int) = {
  strict check = [
      orderContractList.containsElement(i.caller.toString()) || throwErr("permission denied")
  ]

  loanPaymentHelper(user, assetId, amount)
}