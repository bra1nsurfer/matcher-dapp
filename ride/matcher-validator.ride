{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"

let CONTRACT_NAME = "matcher-validator.ride"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

let PENDING       = "PENDING"
let WAVES         = "WAVES"
let wavesSignType = "waves-sign"
let ecdsaSignType = "ecdsa-sign"
let orderDirBuy   = "buy"
let orderDirSell  = "sell"
let MAKER         = "maker"
let TAKER         = "taker"
let dec8          = 1_0000_0000

# ORDER STATUS
let O_OPEN     = 0
let O_FILLED   = 1
let O_CANCELED = 2

# ORDER TYPE
let O_SPOT     = 0
let O_LEVERAGE = 1
let O_MARGIN   = 2

let kFactoryAddress = ["%s", "factoryAddress"].makeString(SEP)
let factoryAddressString = this.getString(kFactoryAddress).valueOrErrorMessage("factory address is not set")
let factoryAddress = factoryAddressString.addressFromString().valueOrErrorMessage("invalid factory address")

let kForceStop = ["%s", "forceStop"].makeString(SEP)
let forceStop  = factoryAddress.getBoolean(kForceStop).valueOrElse(false)

let kMatcherPublicKey = ["%s", "matcherPublicKey"].makeString(SEP)
let matcherPublicKey  = factoryAddress.getString(kMatcherPublicKey).valueOrElse("").fromBase58String()

let (NETWORK, CUR_TIMESTAMP) = match (blockInfoByHeight(height)) {
  case a:BlockInfo => (a.generator.bytes.drop(1).take(1), a.timestamp)
  case _ => throwErr("network byte error: block is not found")
}

let kAllowedAssets = ["%s", "allowedAssets"].makeString(SEP)
let allowedAssets  = match (factoryAddress.getString(kAllowedAssets)) {
    case s:String => s.split_4C(SEP)
    case _ => []
  }

let keyIdCounter = ["%s", "counter"].makeString(SEP)
let O_COUNTER = this.getInteger(keyIdCounter).valueOrElse(0)

func keyInternalIdToOrderId(internalId: Int) = ["%s%d", "internalId", internalId.toString()].makeString(SEP)
func keyOrderRemaining(orderId: String)      = ["%s%s", "orderRemaining", orderId].makeString(SEP)
func keyOrderStatus(orderId: String)         = ["%s%s", "orderStatus", orderId].makeString(SEP)

func amountAssetToPriceAsset(amount: Int, price: Int, amountDecimals: Int) = {
  fraction(amount, price, pow(10, 0, amountDecimals, 0, 0, DOWN), DOWN)
}

func priceAssetToAmountAsset(priceAssetAmount: Int, price: Int, amountDecimals: Int) = {
  fraction(priceAssetAmount, pow(10, 0, amountDecimals, 0, 0, DOWN), price, CEILING)
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

func padBytes(x: ByteVector) = {
  let a = 0.toBytes()
  a + a.drop(x.size()) + x
}

func bytesToInt(x: ByteVector) = {
  x.padBytes().toBigInt().toInt()
}

func toUint256(n: ByteVector) = {
  # 32 zeroes
  let z = base58'11111111111111111111111111111111'
  let pad = z.drop(n.size())
  (pad + n)
}

func toShort(val: ByteVector) = (0.toBytes() + val).takeRight(2)
func getLenAsShort(val: ByteVector) = val.size().toBytes().takeRight(2)
func getBytesWithLen(val: ByteVector) = (val.getLenAsShort() + val)

func getAssetDecimals(assetId: String) = {
  match (assetId.stringToAssetId()) {
    case b:ByteVector => {
      match (assetInfo(b)) {
        case a:Asset => a.decimals
        case _ => 0
      }
    }
    case _ => 8
  }
}

func getEipOrderDataHashV1(orderId: String) = {
  ### EIP-712
  ### ABI encoding

  # Constant prefix [25, 1]
  let prefix = base58'2uN'

  ### Domain typed data
  ###
  let domainType = "EIP712Domain(uint256 chainId)".toBytes().keccak256()
  let domainValue = NETWORK.toUint256()
  let domain = keccak256(domainType + domainValue)

  ### Message typed data
  ###
  let messageType = "Message(string text)".toBytes().keccak256()
  let messageValue = orderId.toBytes().keccak256()
  let message = keccak256(messageType + messageValue)

  keccak256(prefix + domain + message)
}

func getEipOrderDataHashV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      )) = {
  let (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  ) = orderData

  ### EIP-712
  ### ABI encoding

  # Constant prefix [25, 1]
  let prefix = base58'2uN'

  ### Domain typed data
  ###
  let domainType = "EIP712Domain(uint256 chainId)".toBytes().keccak256()
  let domainValue = NETWORK.toUint256()
  let domain = keccak256(domainType + domainValue)

  ### Message typed data
  ###
  let messageType     = "TypedData(int64 version,string network,string sender,string matcherPublicKey,string amountAssetId,string priceAssetId,int64 orderType,string orderDirection,int64 amount,int64 price,int64 timestamp,int64 expiration,int64 flags)".toBytes().keccak256()
  let versionHash     = 2.toBytes().toUint256()
  let networkHash     = networkByte.keccak256()
  let senderHash      = senderBytes.toBase58String().toBytes().keccak256()
  let matcherHash     = matcherPublicKey.toBase58String().toBytes().keccak256()
  let amountAssetHash = amountAsset.assetIdToString().toBytes().keccak256()
  let priceAssetHash  = priceAsset.assetIdToString().toBytes().keccak256()
  let orderTypeHash   = orderType.toBytes().toUint256()
  let orderDirHash    = orderDir.toBytes().keccak256()
  let amountHash      = amount.toBytes().toUint256()
  let priceHash       = price.toBytes().toUint256()
  let timestampHash   = timestamp.toBytes().toUint256()
  let expirationHash  = expiration.toBytes().toUint256()
  let flagsHash       = flags.toUint256()

  let message = keccak256(
    messageType + 
    versionHash +
    networkHash +
    senderHash +
    matcherHash +
    amountAssetHash +
    priceAssetHash +
    orderTypeHash +
    orderDirHash +
    amountHash +
    priceHash +
    timestampHash +
    expirationHash +
    flagsHash
    )


  keccak256(prefix + domain + message)
}

func getOrderBytesV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      )) = {
  let (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  ) = orderData

  # Signer padding V2
  # Prefix: [255, 255, 255, 2]
  let prefix = base58'7YXq4u'

  let LONG    = 0.toBytes().takeRight(1)
  let BOOLEAN = 1.toBytes().takeRight(1)
  let BYTES   = 2.toBytes().takeRight(1)
  let STRING  = 3.toBytes().takeRight(1)

  let versionKey   = "version".toBytes()
  let versionValue = 2.toBytes()

  let networkKey   = "network".toBytes()
  let networkValue = networkByte

  let senderKey   = "sender".toBytes()
  let senderValue = senderBytes.toBase58String().toBytes()

  let matcherKey   = "matcherPublicKey".toBytes()
  let matcherValue = matcherBytes.toBase58String().toBytes()

  let amountAssetKey = "amountAssetId".toBytes()
  let amountAssetValue = amountAsset.assetIdToString().toBytes()

  let priceAssetKey   = "priceAssetId".toBytes()
  let priceAssetValue = priceAsset.assetIdToString().toBytes()

  let orderTypeKey   = "orderType".toBytes()
  let orderTypeValue = orderType.toBytes()

  let orderDirKey   = "orderDirection".toBytes()
  let orderDirValue = orderDir.toBytes()

  let amountKey   = "amount".toBytes()
  let amountValue = amount.toBytes()

  let priceKey   = "price".toBytes()
  let priceValue = price.toBytes()

  let timestampKey   = "timestamp".toBytes()
  let timestampValue = timestamp.toBytes()

  let expirationKey   = "expiration".toBytes()
  let expirationValue = expiration.toBytes()

  let flagsKey   = "flags".toBytes()
  let flagsValue = flags

  prefix + 13.toBytes().toShort() + # 13 - amount of fields in order
  versionKey.getBytesWithLen() + LONG + versionValue +
  networkKey.getBytesWithLen() + STRING + networkValue.getBytesWithLen() +
  senderKey.getBytesWithLen() + STRING + senderValue.getBytesWithLen() +
  matcherKey.getBytesWithLen() + STRING + matcherValue.getBytesWithLen() +
  amountAssetKey.getBytesWithLen() + STRING + amountAssetValue.getBytesWithLen() +
  priceAssetKey.getBytesWithLen() + STRING + priceAssetValue.getBytesWithLen() +
  orderTypeKey.getBytesWithLen() + LONG + orderTypeValue +
  orderDirKey.getBytesWithLen() + STRING + orderDirValue.getBytesWithLen() +
  amountKey.getBytesWithLen() + LONG + amountValue +
  priceKey.getBytesWithLen() + LONG + priceValue +
  timestampKey.getBytesWithLen() + LONG + timestampValue +
  expirationKey.getBytesWithLen() + LONG + expirationValue +
  flagsKey.getBytesWithLen() + LONG + flagsValue
}

func checkSignV1(orderId: String, proof: ByteVector, pubKey: (String, ByteVector)) = {
  let (pubKeyType, senderBytes) = pubKey

  let wavesCheck = if (pubKeyType == wavesSignType) 
    then {
      # Signer padding 
      # Prefix: [255, 255, 255, 1]
      let prefix = base58'7YXq4t'
      let orderIdBytes = prefix + orderId.toBytes()
      (sigVerify(orderIdBytes, proof, senderBytes))
    }
    else false
  let ecdsaCheck = if (pubKeyType == ecdsaSignType) 
    then {
      let address = Address(senderBytes)
      let orderDataHash = getEipOrderDataHashV1(orderId)
      (ecrecover(orderDataHash, proof).addressFromPublicKey() == address)
    }
    else false
  
  wavesCheck || ecdsaCheck
}

func checkSignV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      ),
    proof: ByteVector, 
    pubKey: (String, ByteVector)) = {
  let (pubKeyType, senderBytes) = pubKey
  let wavesCheck = if (pubKeyType == wavesSignType) 
    then {
      let signedBytes = getOrderBytesV2(orderData)
      (sigVerify(signedBytes, proof, senderBytes))
    }
    else false
  let ecdsaCheck = if (pubKeyType == ecdsaSignType) 
    then {
      let address = Address(senderBytes)
      let orderDataHash = getEipOrderDataHashV2(orderData)
      (ecrecover(orderDataHash, proof).addressFromPublicKey() == address)
    }
    else false
  
  wavesCheck || ecdsaCheck
}

func parseOrderV1(orderBytes: ByteVector) = {
  let networkByte = orderBytes.drop(1).take(1)
  let data1 = orderBytes.drop(2)
  
  # Waves pubKey or address (EIP-712)
  let senderFlag = data1.take(1).bytesToInt()
  let data2 = data1.drop(1)
  let (senderBytesLen, pubKeyType) = if(senderFlag == 0) 
    then (32, wavesSignType) 
    else (26, ecdsaSignType)
  let senderBytes = data2.take(senderBytesLen)
  let data3 = data2.drop(senderBytesLen)

  let matcherBytesLen = 32
  let matcherBytes = data3.take(matcherBytesLen)
  let data4 = data3.drop(matcherBytesLen)

  let amountAssetFlag = data4.take(1).bytesToInt()
  let data5 = data4.drop(1)
  let amountAssetLen = if(amountAssetFlag == 0) then 0 else 32
  let amountAsset = if(amountAssetLen == 0) then unit else data5.take(amountAssetLen)
  let data6 = data5.drop(amountAssetLen)

  let priceAssetFlag = data6.take(1).bytesToInt()
  let data7 = data6.drop(1)
  let priceAssetLen = if(priceAssetFlag == 0) then 0 else 32
  let priceAsset = if(priceAssetLen == 0) then unit else data7.take(priceAssetLen)
  let data8 = data7.drop(priceAssetLen)

  let orderType = data8.take(1).bytesToInt()
  let data9 = data8.drop(1)

  let orderDirByte = data9.take(1).bytesToInt()
  let orderDir = if (orderDirByte == 0) then orderDirBuy else orderDirSell
  let data10 = data9.drop(1)

  let amount = data10.take(8).bytesToInt()
  let data11 = data10.drop(8)

  let price = data11.take(8).bytesToInt()
  let data12 = data11.drop(8)

  let timestamp = data12.take(8).bytesToInt()
  let data13 = data12.drop(8)
  
  let expiration = data13.take(8).bytesToInt()
  let data14 = data13.drop(8)

  let flags = data14.take(8)
  
  (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  )
}

func parseOrder(orderBytes: ByteVector, proof: ByteVector) = {
  let version = orderBytes.take(1).bytesToInt()

  let orderData = if (version == 1 || version == 2) 
    then parseOrderV1(orderBytes) 
    else throwErr("order version is not supported")
  let orderId = sha256(orderBytes).toBase58String()
  let orderStatus = this.getInteger(keyOrderStatus(orderId)).valueOrElse(O_OPEN)
  let (pubKeyType, pubKey) = (orderData._2, orderData._3)
  
  let signCheck = if (version == 1) 
    then checkSignV1(orderId, proof, (pubKeyType, pubKey))
    else if (version == 2) 
      then checkSignV2(orderData, proof, (pubKeyType, pubKey))
      else false

  strict check = [
    signCheck || throwErr(["order proof is not valid ", orderId].makeString(" "))
  ]

  (orderData, orderId, orderStatus)
}

func getRemainingAmount(orderId: String, fullAmount: Int) = {
  let remainingAmount = this.getInteger(keyOrderRemaining(orderId)).valueOrElse(fullAmount)
  let filled = max([fullAmount - remainingAmount, 0])

  (remainingAmount, filled)
}

func matchOrders(
  o1Bytes       : ByteVector,
  o1proof       : ByteVector,
  o2Bytes       : ByteVector,
  o2proof       : ByteVector,
  matchAmount   : Int,
  matchPrice    : Int,
  makerFeeAsset : String,
  makerFeeAmount: Int,
  takerFeeAsset : String,
  takerFeeAmount: Int
  ) = {

  ### parseOrder struct
  #   ._1  networkByte,
  #   ._2  pubKeyType,
  #   ._3  senderBytes,
  #   ._4  matcherBytes,
  #   ._5  amountAsset,
  #   ._6  priceAsset,
  #   ._7  orderType,
  #   ._8  orderDirection,
  #   ._9  amount,
  #   ._10 price,
  #   ._11 timestamp (nonce)
  #   ._12 expiration | 0
  #   ._13 flags
  let (makerOrder, makerOrderId, makerOrderStatus) = parseOrder(o1Bytes, o1proof)
  let (takerOrder, takerOrderId, takerOrderStatus) = parseOrder(o2Bytes, o2proof)

  let makerOrderNetwork      = makerOrder._1
  let makerOrderPubKeyType   = makerOrder._2
  let makerOrderSenderBytes  = makerOrder._3
  let makerOrderMatcherBytes = makerOrder._4
  let makerOrderAmountAsset  = makerOrder._5.assetIdToString()
  let makerOrderPriceAsset   = makerOrder._6.assetIdToString()
  let makerOrderType         = makerOrder._7
  let makerOrderDir          = makerOrder._8
  let makerOrderFullAmount   = makerOrder._9
  let makerOrderPrice        = makerOrder._10
  let makerOrderNonce        = makerOrder._11
  let makerOrderExpiration   = makerOrder._12
  let makerOrderFlags        = makerOrder._13
  
  let takerOrderNetwork      = takerOrder._1
  let takerOrderPubKeyType   = takerOrder._2
  let takerOrderSenderBytes  = takerOrder._3
  let takerOrderMatcherBytes = takerOrder._4
  let takerOrderAmountAsset  = takerOrder._5.assetIdToString()
  let takerOrderPriceAsset   = takerOrder._6.assetIdToString()
  let takerOrderType         = takerOrder._7
  let takerOrderDir          = takerOrder._8
  let takerOrderFullAmount   = takerOrder._9
  let takerOrderPrice        = takerOrder._10
  let takerOrderNonce        = takerOrder._11
  let takerOrderExpiration   = takerOrder._12
  let takerOrderFlags        = takerOrder._13

  strict validation = [
    (makerOrderNetwork == NETWORK && takerOrderNetwork == NETWORK) || throwErr("network byte is not valid"),
    (makerOrderMatcherBytes == matcherPublicKey) || throwErr("maker order matcher bytes does not match"),
    (takerOrderMatcherBytes == matcherPublicKey) || throwErr("taker order matcher bytes does not match"),
    (makerOrderAmountAsset == takerOrderAmountAsset) || throwErr("amount asset Id does not match"),
    (makerOrderPriceAsset == takerOrderPriceAsset) || throwErr("price asset Id does not match"),
    (makerOrderType == takerOrderType) || throwErr("order type does not match"),
    (makerOrderDir != takerOrderDir) || throwErr("order direction bytes is not valid"),
    (makerOrderDir == orderDirBuy && matchPrice <= makerOrderPrice) || (makerOrderDir == orderDirSell && matchPrice >= makerOrderPrice) || throwErr("maker order price error"),
    (takerOrderDir == orderDirBuy && matchPrice <= takerOrderPrice) || (takerOrderDir == orderDirSell && matchPrice >= takerOrderPrice) || throwErr("taker order price error"),
    (makerOrderExpiration == 0 || makerOrderExpiration >= CUR_TIMESTAMP) || throwErr("maker order is expired"),
    (takerOrderExpiration == 0 || takerOrderExpiration >= CUR_TIMESTAMP) || throwErr("taker order is expired"),
    (makerOrderStatus == O_OPEN) || throwErr("maker order is closed"),
    (takerOrderStatus == O_OPEN) || throwErr("taker order is closed"),
    (makerOrderId != takerOrderId) || throwErr("maker order and taker order are the same"),
    (makerOrderAmountAsset != makerOrderPriceAsset) || throwErr("amount asset and price asset are the same"),
    (allowedAssets.containsElement(makerOrderAmountAsset)) || throwErr("amount asset not in the allowed list"),
    (allowedAssets.containsElement(makerOrderPriceAsset)) || throwErr("price asset not in the allowed list")
  ]

  let makerOrderSenderAddress = 
    if(makerOrderPubKeyType == ecdsaSignType) 
    then Address(makerOrderSenderBytes) 
    else addressFromPublicKey(makerOrderSenderBytes)
  let takerOrderSenderAddress = 
    if(takerOrderPubKeyType == ecdsaSignType) 
    then Address(takerOrderSenderBytes) 
    else addressFromPublicKey(takerOrderSenderBytes)

  let (makerRawRemaining, _makerFilled) = getRemainingAmount(makerOrderId, makerOrderFullAmount)
  let (takerRawRemaining, _takerFilled) = getRemainingAmount(takerOrderId, takerOrderFullAmount)

  let amountAssetDecimals = getAssetDecimals(makerOrderAmountAsset)

  # If order fee asset is the same as order sending asset
  # decrease order amount by fee
  let makerRemaining = 
    if (makerOrderDir == orderDirSell && makerOrderAmountAsset == makerFeeAsset)
      then makerRawRemaining - makerFeeAmount
      else if (makerOrderDir == orderDirBuy && makerOrderPriceAsset == makerFeeAsset) 
        then (makerRawRemaining - priceAssetToAmountAsset(makerFeeAmount, makerOrderPrice, amountAssetDecimals)) 
        else makerRawRemaining

  let takerRemaining = 
    if (takerOrderDir == orderDirSell && takerOrderAmountAsset == takerFeeAsset)
      then takerRawRemaining - takerFeeAmount
      else if (takerOrderDir == orderDirBuy && takerOrderPriceAsset == takerFeeAsset) 
        then (takerRawRemaining - priceAssetToAmountAsset(takerFeeAmount, takerOrderPrice, amountAssetDecimals)) 
        else takerRawRemaining

  # If matchAmount is set to `-1`, match orders with maximum available amount
  let realMatchAmount = if (matchAmount == -1) then min([makerRemaining, takerRemaining]) else matchAmount

  strict check2 = [
    realMatchAmount >= 0 || "cannot match negative amount".throwErr(),
    realMatchAmount <= makerRemaining || ["matched amount exceeds maker order remaining amount (", makerRemaining.toString(), ")"].makeString("").throwErr(),
    realMatchAmount <= takerRemaining || ["matched amount exceeds taker order remaining amount (", takerRemaining.toString(), ")"].makeString("").throwErr()
  ]

  let matchAmountInPriceAsset = amountAssetToPriceAsset(realMatchAmount, matchPrice, amountAssetDecimals)

  let newMakerRemaining = makerRemaining - realMatchAmount
  let newTakerRemaining = takerRemaining - realMatchAmount

  let newMakerFilled = makerOrderFullAmount - newMakerRemaining
  let newTakerFilled = takerOrderFullAmount - newTakerRemaining

  # Convert remaining amount to price asset at order price
  let makerPriceAssetRem = amountAssetToPriceAsset(newMakerRemaining, makerOrderPrice, amountAssetDecimals)
  let takerPriceAssetRem = amountAssetToPriceAsset(newTakerRemaining, takerOrderPrice, amountAssetDecimals)

  let (makerSendAsset, makerSendAmount, makerGetAsset, makerGetAmount) = 
    if (makerOrderDir == orderDirBuy)
    then (makerOrderPriceAsset, matchAmountInPriceAsset, makerOrderAmountAsset, realMatchAmount)
    else (makerOrderAmountAsset, realMatchAmount, makerOrderPriceAsset, matchAmountInPriceAsset)

  let (takerSendAsset, takerSendAmount, takerGetAsset, takerGetAmount) = 
    if (takerOrderDir == orderDirBuy)
    then (takerOrderPriceAsset, matchAmountInPriceAsset, takerOrderAmountAsset, realMatchAmount)
    else (takerOrderAmountAsset, realMatchAmount, takerOrderPriceAsset, matchAmountInPriceAsset)

  (
    makerOrderType,
    (makerOrderSenderAddress.toString(), makerSendAsset, makerSendAmount, makerGetAsset, makerGetAmount, makerOrderFlags),
    (takerOrderSenderAddress.toString(), takerSendAsset, takerSendAmount, takerGetAsset, takerGetAmount, takerOrderFlags),
    (makerOrderId, newMakerFilled, newMakerRemaining, makerPriceAssetRem), 
    (takerOrderId, newTakerFilled, newTakerRemaining, takerPriceAssetRem)
  )
}

func getOrderTypeContract(orderType: Int) = {
  let addressString = factoryAddress.invoke("getOrderTypeContract", [orderType], [])
  
  match (addressString) {
      case s:String => s.addressFromString()
      case _ => unit
    }
}

# o1 - Maker
# o2 - Taker
@Callable(i)
func validateAndExchange(
  o1bytes       : ByteVector,
  o1proof       : ByteVector,
  o2bytes       : ByteVector,
  o2proof       : ByteVector,
  matchAmount   : Int,
  matchPrice    : Int,
  makerFeeAsset : String,
  makerFeeAmount: Int,
  takerFeeAsset : String,
  takerFeeAmount: Int
  ) = {
  
  let (orderType, makerStateChanges, takerStateChanges, makerOrderState, takerOrderState) = 
    matchOrders(
      o1bytes, 
      o1proof, 
      o2bytes, 
      o2proof, 
      matchAmount, 
      matchPrice, 
      makerFeeAsset,
      makerFeeAmount,
      takerFeeAsset,
      takerFeeAmount
    )

  # Order state
  let makerOrderId            = makerOrderState._1
  let makerOrderFilled        = makerOrderState._2
  let makerOrderRemaining     = makerOrderState._3
  let makerOrderPriceAssetRem = makerOrderState._4

  let takerOrderId            = takerOrderState._1
  let takerOrderFilled        = takerOrderState._2
  let takerOrderRemaining     = takerOrderState._3
  let takerOrderPriceAssetRem = takerOrderState._4

  # Matched values
  let makerAddress    = makerStateChanges._1
  let makerSendAsset  = makerStateChanges._2
  let makerSendAmount = makerStateChanges._3
  let makerGetAsset   = makerStateChanges._4
  let makerGetAmount  = makerStateChanges._5
  let makerFlags      = makerStateChanges._6

  let takerAddress    = takerStateChanges._1
  let takerSendAsset  = takerStateChanges._2
  let takerSendAmount = takerStateChanges._3
  let takerGetAsset   = takerStateChanges._4
  let takerGetAmount  = takerStateChanges._5
  let takerFlags      = takerStateChanges._6

  strict checks = [
    # TODO: Enable after testing
    # i.callerPublicKey == matcherPublicKey || throwErr("permission denied"),
    !forceStop || throwErr("contract is temporary stopped"),
    makerSendAmount > 0 || throwErr("cannot send zero from maker"),
    makerGetAmount > 0 || throwErr("cannot get zero to maker"),
    takerSendAmount > 0 || throwErr("cannot send zero from taker"),
    takerGetAmount > 0 || throwErr("cannot get zero to taker")
  ]

  let (makerOrderInternalId, makerOrderIdAction) = 
    if(isDefined(this.getInteger(keyOrderRemaining(makerOrderId))))
    then (O_COUNTER, nil)
    else (O_COUNTER+1, [StringEntry(keyInternalIdToOrderId(O_COUNTER+1), makerOrderId)])

  let (takerOrderInternalId, takerOrderIdAction) = 
    if(isDefined(this.getInteger(keyOrderRemaining(takerOrderId))))
    then (makerOrderInternalId, nil)
    else (makerOrderInternalId+1, [StringEntry(keyInternalIdToOrderId(makerOrderInternalId+1), takerOrderId)])

  let counterAction = 
    if(O_COUNTER != takerOrderInternalId) 
    then [IntegerEntry(keyIdCounter, takerOrderInternalId)]
    else nil

  let orderTypeContract = getOrderTypeContract(orderType).valueOrErrorMessage("order type contract error")

  strict exchange = [
    orderTypeContract.invoke(
      "exchange",
      [
        makerAddress,
        makerSendAsset,
        makerSendAmount,
        makerGetAsset,
        makerGetAmount,
        makerFlags,
        makerFeeAsset,
        makerFeeAmount,
        takerAddress,
        takerSendAsset,
        takerSendAmount,
        takerGetAsset,
        takerGetAmount,
        takerFlags,
        takerFeeAsset,
        takerFeeAmount
      ],
      []
    )
  ]

  # Set remaining amount to `0` if it's fully filled
  let (makerOrderStatusAction, makerOrderRealRemaining) = 
    if (makerOrderPriceAssetRem <= 0) 
    then ([IntegerEntry(keyOrderStatus(makerOrderId), O_FILLED)], 0)
    else (nil, makerOrderRemaining)

  let (takerOrderStatusAction, takerOrderRealRemaining) =
    if (takerOrderPriceAssetRem <= 0) 
    then ([IntegerEntry(keyOrderStatus(takerOrderId), O_FILLED)], 0) 
    else (nil, takerOrderRemaining)

  let updateOrderActions = [
    IntegerEntry(keyOrderRemaining(makerOrderId), makerOrderRealRemaining),
    IntegerEntry(keyOrderRemaining(takerOrderId), takerOrderRealRemaining)
  ]

  updateOrderActions ++ 
  makerOrderIdAction ++
  takerOrderIdAction ++
  counterAction ++
  makerOrderStatusAction ++
  takerOrderStatusAction
}

@Callable(i)
func init(matcherFactory: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [StringEntry(kFactoryAddress, matcherFactory)]
}
