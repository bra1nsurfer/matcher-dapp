{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"

let CONTRACT_NAME = "matcher-validator.ride"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

let PENDING       = "PENDING"
let WAVES         = "WAVES"
let wavesSignType = "waves-sign"
let ecdsaSignType = "ecdsa-sign"
let orderDirBuy   = "buy"
let orderDirSell  = "sell"
let MAKER         = "maker"
let TAKER         = "taker"
let dec8          = 1_0000_0000

# ORDER STATUS
let O_OPEN     = 0
let O_FILLED   = 1
let O_CANCELED = 2

# ORDER TYPE
let O_SPOT     = 0
let O_LEVERAGE = 1
let O_MARGIN   = 2

let kFactoryAddress = ["%s", "factoryAddress"].makeString(SEP)
let factoryAddressString = this.getString(kFactoryAddress).valueOrErrorMessage("factory address is not set")
let factoryAddress = factoryAddressString.addressFromString().valueOrErrorMessage("invalid factory address")

let kForceStop = ["%s", "forceStop"].makeString(SEP)
let forceStop  = factoryAddress.getBoolean(kForceStop).valueOrElse(false)

let kMatcherPublicKey = ["%s", "matcherPublicKey"].makeString(SEP)
let matcherPublicKey  = factoryAddress.getString(kMatcherPublicKey).valueOrElse("").fromBase58String()

let (NETWORK, CUR_TIMESTAMP) = match (blockInfoByHeight(height)) {
  case a:BlockInfo => (a.generator.bytes.drop(1).take(1), a.timestamp)
  case _ => throwErr("network byte error: block is not found")
}

let kAllowedAssets = ["%s", "allowedAssets"].makeString(SEP)
let allowedAssets  = match (factoryAddress.getString(kAllowedAssets)) {
    case s:String => s.split_4C(SEP)
    case _ => []
  }

let keyIdCounter = ["%s", "counter"].makeString(SEP)
let O_COUNTER = this.getInteger(keyIdCounter).valueOrElse(0)

func keyInternalIdToOrderId(internalId: Int) = ["%s%d", "internalId", internalId.toString()].makeString(SEP)
func keyOrderRemaining(orderId: String)      = ["%s%s", "orderRemaining", orderId].makeString(SEP)
func keyOrderStatus(orderId: String)         = ["%s%s", "orderStatus", orderId].makeString(SEP)

func calcSendAmount(amount: Int, price: Int) = {
  fraction(amount, price, dec8)
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

func padBytes(x: ByteVector) = {
  let a = 0.toBytes()
  a + a.drop(x.size()) + x
}

func bytesToInt(x: ByteVector) = {
  x.padBytes().toBigInt().toInt()
}

func toUint256(n: ByteVector) = {
  # 32 zeroes
  let z = base58'11111111111111111111111111111111'
  let pad = z.drop(n.size())
  (pad + n)
}

func toShort(val: ByteVector) = (0.toBytes() + val).takeRight(2)
func getLenAsShort(val: ByteVector) = val.size().toBytes().takeRight(2)
func getBytesWithLen(val: ByteVector) = (val.getLenAsShort() + val)

func getEipOrderDataHashV1(orderId: String) = {
  ### EIP-712
  ### ABI encoding

  # Constant prefix [25, 1]
  let prefix = base58'2uN'

  ### Domain typed data
  ###
  let domainType = "EIP712Domain(uint256 chainId)".toBytes().keccak256()
  let domainValue = NETWORK.toUint256()
  let domain = keccak256(domainType + domainValue)

  ### Message typed data
  ###
  let messageType = "Message(string text)".toBytes().keccak256()
  let messageValue = orderId.toBytes().keccak256()
  let message = keccak256(messageType + messageValue)

  keccak256(prefix + domain + message)
}

func getEipOrderDataHashV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      )) = {
  let (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  ) = orderData

  ### EIP-712
  ### ABI encoding

  # Constant prefix [25, 1]
  let prefix = base58'2uN'

  ### Domain typed data
  ###
  let domainType = "EIP712Domain(uint256 chainId)".toBytes().keccak256()
  let domainValue = NETWORK.toUint256()
  let domain = keccak256(domainType + domainValue)

  ### Message typed data
  ###
  let messageType     = "TypedData(int64 version,string network,string sender,string matcherPublicKey,string amountAssetId,string priceAssetId,int64 orderType,string orderDirection,int64 amount,int64 price,int64 timestamp,int64 expiration,int64 flags)".toBytes().keccak256()
  let versionHash     = 2.toBytes().toUint256()
  let networkHash     = networkByte.keccak256()
  let senderHash      = senderBytes.toBase58String().toBytes().keccak256()
  let matcherHash     = matcherPublicKey.toBase58String().toBytes().keccak256()
  let amountAssetHash = amountAsset.assetIdToString().toBytes().keccak256()
  let priceAssetHash  = priceAsset.assetIdToString().toBytes().keccak256()
  let orderTypeHash   = orderType.toBytes().toUint256()
  let orderDirHash    = orderDir.toBytes().keccak256()
  let amountHash      = amount.toBytes().toUint256()
  let priceHash       = price.toBytes().toUint256()
  let timestampHash   = timestamp.toBytes().toUint256()
  let expirationHash  = expiration.toBytes().toUint256()
  let flagsHash       = flags.toUint256()

  let message = keccak256(
    messageType + 
    versionHash +
    networkHash +
    senderHash +
    matcherHash +
    amountAssetHash +
    priceAssetHash +
    orderTypeHash +
    orderDirHash +
    amountHash +
    priceHash +
    timestampHash +
    expirationHash +
    flagsHash
    )


  keccak256(prefix + domain + message)
}

func getOrderBytesV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      )) = {
  let (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  ) = orderData

  # Signer padding V2
  # Prefix: [255, 255, 255, 2]
  let prefix = base58'7YXq4u'

  let LONG    = 0.toBytes().takeRight(1)
  let BOOLEAN = 1.toBytes().takeRight(1)
  let BYTES   = 2.toBytes().takeRight(1)
  let STRING  = 3.toBytes().takeRight(1)

  let versionKey   = "version".toBytes()
  let versionValue = 2.toBytes()

  let networkKey   = "network".toBytes()
  let networkValue = networkByte

  let senderKey   = "sender".toBytes()
  let senderValue = senderBytes.toBase58String().toBytes()

  let matcherKey   = "matcherPublicKey".toBytes()
  let matcherValue = matcherBytes.toBase58String().toBytes()

  let amountAssetKey = "amountAssetId".toBytes()
  let amountAssetValue = amountAsset.assetIdToString().toBytes()

  let priceAssetKey   = "priceAssetId".toBytes()
  let priceAssetValue = priceAsset.assetIdToString().toBytes()

  let orderTypeKey   = "orderType".toBytes()
  let orderTypeValue = orderType.toBytes()

  let orderDirKey   = "orderDirection".toBytes()
  let orderDirValue = orderDir.toBytes()

  let amountKey   = "amount".toBytes()
  let amountValue = amount.toBytes()

  let priceKey   = "price".toBytes()
  let priceValue = price.toBytes()

  let timestampKey   = "timestamp".toBytes()
  let timestampValue = timestamp.toBytes()

  let expirationKey   = "expiration".toBytes()
  let expirationValue = expiration.toBytes()

  let flagsKey   = "flags".toBytes()
  let flagsValue = flags

  prefix + 13.toBytes().toShort() + # 13 - amount of fields in order
  versionKey.getBytesWithLen() + LONG + versionValue +
  networkKey.getBytesWithLen() + STRING + networkValue.getBytesWithLen() +
  senderKey.getBytesWithLen() + STRING + senderValue.getBytesWithLen() +
  matcherKey.getBytesWithLen() + STRING + matcherValue.getBytesWithLen() +
  amountAssetKey.getBytesWithLen() + STRING + amountAssetValue.getBytesWithLen() +
  priceAssetKey.getBytesWithLen() + STRING + priceAssetValue.getBytesWithLen() +
  orderTypeKey.getBytesWithLen() + LONG + orderTypeValue +
  orderDirKey.getBytesWithLen() + STRING + orderDirValue.getBytesWithLen() +
  amountKey.getBytesWithLen() + LONG + amountValue +
  priceKey.getBytesWithLen() + LONG + priceValue +
  timestampKey.getBytesWithLen() + LONG + timestampValue +
  expirationKey.getBytesWithLen() + LONG + expirationValue +
  flagsKey.getBytesWithLen() + LONG + flagsValue
}

func checkSignV1(orderId: String, proof: ByteVector, pubKey: (String, ByteVector)) = {
  let (pubKeyType, senderBytes) = pubKey

  let wavesCheck = if (pubKeyType == wavesSignType) 
    then {
      # Signer padding 
      # Prefix: [255, 255, 255, 1]
      let prefix = base58'7YXq4t'
      let orderIdBytes = prefix + orderId.toBytes()
      (sigVerify(orderIdBytes, proof, senderBytes))
    }
    else false
  let ecdsaCheck = if (pubKeyType == ecdsaSignType) 
    then {
      let address = Address(senderBytes)
      let orderDataHash = getEipOrderDataHashV1(orderId)
      (ecrecover(orderDataHash, proof).addressFromPublicKey() == address)
    }
    else false
  
  wavesCheck || ecdsaCheck
}

func checkSignV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      ),
    proof: ByteVector, 
    pubKey: (String, ByteVector)) = {
  let (pubKeyType, senderBytes) = pubKey
  let wavesCheck = if (pubKeyType == wavesSignType) 
    then {
      let signedBytes = getOrderBytesV2(orderData)
      (sigVerify(signedBytes, proof, senderBytes))
    }
    else false
  let ecdsaCheck = if (pubKeyType == ecdsaSignType) 
    then {
      let address = Address(senderBytes)
      let orderDataHash = getEipOrderDataHashV2(orderData)
      (ecrecover(orderDataHash, proof).addressFromPublicKey() == address)
    }
    else false
  
  wavesCheck || ecdsaCheck
}

func parseOrderV1(orderBytes: ByteVector) = {
  let networkByte = orderBytes.drop(1).take(1)
  let data1 = orderBytes.drop(2)
  
  # Waves pubKey or address (EIP-712)
  let senderFlag = data1.take(1).bytesToInt()
  let data2 = data1.drop(1)
  let (senderBytesLen, pubKeyType) = if(senderFlag == 0) 
    then (32, wavesSignType) 
    else (26, ecdsaSignType)
  let senderBytes = data2.take(senderBytesLen)
  let data3 = data2.drop(senderBytesLen)

  let matcherBytesLen = 32
  let matcherBytes = data3.take(matcherBytesLen)
  let data4 = data3.drop(matcherBytesLen)

  let amountAssetFlag = data4.take(1).bytesToInt()
  let data5 = data4.drop(1)
  let amountAssetLen = if(amountAssetFlag == 0) then 0 else 32
  let amountAsset = if(amountAssetLen == 0) then unit else data5.take(amountAssetLen)
  let data6 = data5.drop(amountAssetLen)

  let priceAssetFlag = data6.take(1).bytesToInt()
  let data7 = data6.drop(1)
  let priceAssetLen = if(priceAssetFlag == 0) then 0 else 32
  let priceAsset = if(priceAssetLen == 0) then unit else data7.take(priceAssetLen)
  let data8 = data7.drop(priceAssetLen)

  let orderType = data8.take(1).bytesToInt()
  let data9 = data8.drop(1)

  let orderDirByte = data9.take(1).bytesToInt()
  let orderDir = if (orderDirByte == 0) then orderDirBuy else orderDirSell
  let data10 = data9.drop(1)

  let amount = data10.take(8).bytesToInt()
  let data11 = data10.drop(8)

  let price = data11.take(8).bytesToInt()
  let data12 = data11.drop(8)

  let timestamp = data12.take(8).bytesToInt()
  let data13 = data12.drop(8)
  
  let expiration = data13.take(8).bytesToInt()
  let data14 = data13.drop(8)

  let flags = data14.take(8)
  
  (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  )
}

func parseOrder(orderBytes: ByteVector, proof: ByteVector) = {
  let version = orderBytes.take(1).bytesToInt()

  let orderData = if (version == 1 || version == 2) 
    then parseOrderV1(orderBytes) 
    else throwErr("order version is not supported")
  let orderId = sha256(orderBytes).toBase58String()
  let orderStatus = this.getInteger(keyOrderStatus(orderId)).valueOrElse(O_OPEN)
  let (pubKeyType, pubKey) = (orderData._2, orderData._3)
  
  let signCheck = if (version == 1) 
    then checkSignV1(orderId, proof, (pubKeyType, pubKey))
    else if (version == 2) 
      then checkSignV2(orderData, proof, (pubKeyType, pubKey))
      else false

  strict check = [
    signCheck || throwErr(["order proof is not valid ", orderId].makeString(" "))
  ]

  (orderData, orderId, orderStatus)
}

func getRemainingAmount(orderId: String, fullAmount: Int) = {
  let remainingAmount = this.getInteger(keyOrderRemaining(orderId)).valueOrElse(fullAmount)
  let filled = max([fullAmount - remainingAmount, 0])

  (remainingAmount, filled)
}

func matchOrders(
  o1Bytes       : ByteVector,
  o1proof       : ByteVector,
  o2Bytes       : ByteVector,
  o2proof       : ByteVector,
  amount        : Int,
  price         : Int,
  makerFeeAsset : String,
  makerFeeAmount: Int,
  takerFeeAsset : String,
  takerFeeAmount: Int
  ) = {

  ### parseOrder struct
  #   ._1  networkByte,
  #   ._2  pubKeyType,
  #   ._3  senderBytes,
  #   ._4  matcherBytes,
  #   ._5  amountAsset,
  #   ._6  priceAsset,
  #   ._7  orderType,
  #   ._8  orderDirection,
  #   ._9  amount,
  #   ._10 price,
  #   ._11 timestamp (nonce)
  #   ._12 expiration | 0
  #   ._13 flags
  let o1 = parseOrder(o1Bytes, o1proof)
  let o2 = parseOrder(o2Bytes, o2proof)

  let (bO, bFeeType, bFeeAsset, bFeeAmount, sO, sFeeType, sFeeAsset, sFeeAmount) = 
    if (o1._1._8 == orderDirBuy) 
      then (o1, MAKER, makerFeeAsset, makerFeeAmount, o2, TAKER, takerFeeAsset, takerFeeAmount) 
      else (o2, TAKER, takerFeeAsset, takerFeeAmount, o1, MAKER, makerFeeAsset, makerFeeAmount)
  let (buyOrder, buyOrderId, buyOrderStatus) = bO
  let (sellOrder, sellOrderId, sellOrderStatus) = sO

  let buyOrderNetwork      = buyOrder._1
  let buyOrderPubKeyType   = buyOrder._2
  let buyOrderSenderBytes  = buyOrder._3
  let buyOrderMatcherBytes = buyOrder._4
  let buyOrderAmountAsset  = buyOrder._5
  let buyOrderPriceAsset   = buyOrder._6
  let buyOrderType         = buyOrder._7
  let buyOrderDir          = buyOrder._8
  let buyOrderFullAmount   = buyOrder._9
  let buyOrderPrice        = buyOrder._10
  let buyOrderNonce        = buyOrder._11
  let buyOrderExpiration   = buyOrder._12
  let buyOrderFlags        = buyOrder._13
  
  let sellOrderNetwork      = sellOrder._1
  let sellOrderPubKeyType   = sellOrder._2
  let sellOrderSenderBytes  = sellOrder._3
  let sellOrderMatcherBytes = sellOrder._4
  let sellOrderAmountAsset  = sellOrder._5
  let sellOrderPriceAsset   = sellOrder._6
  let sellOrderType         = sellOrder._7
  let sellOrderDir          = sellOrder._8
  let sellOrderFullAmount   = sellOrder._9
  let sellOrderPrice        = sellOrder._10
  let sellOrderNonce        = sellOrder._11
  let sellOrderExpiration   = sellOrder._12
  let sellOrderFlags        = sellOrder._13

  strict validation = [
    (buyOrderNetwork == NETWORK && sellOrderNetwork == NETWORK) || throwErr("network byte is not valid"),
    (buyOrderMatcherBytes == matcherPublicKey) || throwErr("buy order matcher bytes does not match"),
    (sellOrderMatcherBytes == matcherPublicKey) || throwErr("sell order matcher bytes does not match"),
    (buyOrderAmountAsset == sellOrderAmountAsset) || throwErr("amount asset Id does not match"),
    (buyOrderPriceAsset == sellOrderPriceAsset) || throwErr("price asset Id does not match"),
    (buyOrderType == sellOrderType) || throwErr("order type does not match"),
    (buyOrderDir == orderDirBuy) || throwErr("buy order direction byte is not valid"),
    (sellOrderDir == orderDirSell) || throwErr("sell order direction byte is not valid"),
    (price <= buyOrderPrice) || throwErr("buy order price error"),
    (price >= sellOrderPrice) || throwErr("sell order price error"),
    (buyOrderExpiration == 0 || buyOrderExpiration >= CUR_TIMESTAMP) || throwErr("buy order is expired"),
    (sellOrderExpiration == 0 || sellOrderExpiration >= CUR_TIMESTAMP) || throwErr("sell order is expired"),
    (buyOrderStatus == O_OPEN) || throwErr("buy order is closed"),
    (sellOrderStatus == O_OPEN) || throwErr("sell order is closed"),
    (buyOrderId != sellOrderId) || throwErr("buy order and sell order are the same"),
    (buyOrderAmountAsset != buyOrderPriceAsset) || throwErr("amount asset and price asset are the same"),
    (allowedAssets.containsElement(buyOrderAmountAsset.assetIdToString())) || throwErr("amount asset not in the allowed list"),
    (allowedAssets.containsElement(buyOrderPriceAsset.assetIdToString())) || throwErr("price asset not in the allowed list")
  ]

  let buyOrderAddress = 
    if(buyOrderPubKeyType == ecdsaSignType) 
    then Address(buyOrderSenderBytes) 
    else addressFromPublicKey(buyOrderSenderBytes)
  let sellOrderAddress = 
    if(sellOrderPubKeyType == ecdsaSignType) 
    then Address(sellOrderSenderBytes) 
    else addressFromPublicKey(sellOrderSenderBytes)

  let (buyAmount, buyFilled) = getRemainingAmount(buyOrderId, buyOrderFullAmount)
  let (sellAmount, sellFilled) = getRemainingAmount(sellOrderId, sellOrderFullAmount)

  let matchedAmount = if (amount <= min([buyAmount, sellAmount])) 
    then amount 
    else throwErr("matched amount exceeds order remaining amount")

  let sendPriceAssetAmount = calcSendAmount(matchedAmount, price)

  let newBuyRemaining  = buyAmount - matchedAmount
  let newSellRemaining = sellAmount - matchedAmount

  let newBuyFilled     = buyOrderFullAmount - newBuyRemaining
  let newSellFilled    = sellOrderFullAmount - newSellRemaining

  # Convert remaining amount to price asset at order price
  let buyPriceAssetRem = calcSendAmount(newBuyRemaining, buyOrderPrice)
  let sellPriceAssetRem = calcSendAmount(newSellRemaining, sellOrderPrice)

  (
    (buyOrderAddress,  matchedAmount,        buyOrderAmountAsset, buyOrderType,  bFeeType, buyOrderFlags),
    (sellOrderAddress, sendPriceAssetAmount, sellOrderPriceAsset, sellOrderType, sFeeType, sellOrderFlags),
    (buyOrderId, newBuyFilled, newBuyRemaining, buyPriceAssetRem), 
    (sellOrderId, newSellFilled, newSellRemaining, sellPriceAssetRem)
  )
}

func getOrderTypeContract(orderType: Int) = {
  let addressString = factoryAddress.invoke("getOrderTypeContract", [orderType], [])
  
  match (addressString) {
      case s:String => s.addressFromString()
      case _ => unit
    }
}

# o1 - Maker
# o2 - Taker
@Callable(i)
func validateAndExchange(
  o1bytes       : ByteVector,
  o1proof       : ByteVector,
  o2bytes       : ByteVector,
  o2proof       : ByteVector,
  matchAmount   : Int,
  matchPrice    : Int,
  makerFeeAsset : String,
  makerFeeAmount: Int,
  takerFeeAsset : String,
  takerFeeAmount: Int
  ) = {
  
  let (buyTransfer, sellTransfer, buyState, sellState) = 
    matchOrders(
      o1bytes, 
      o1proof, 
      o2bytes, 
      o2proof, 
      matchAmount, 
      matchPrice, 
      makerFeeAsset,
      makerFeeAmount,
      takerFeeAsset,
      takerFeeAmount
    )

  # Order state
  let buyOrderId            = buyState._1
  let buyOrderFilled        = buyState._2
  let buyOrderRemaining     = buyState._3
  let buyOrderPriceAssetRem = buyState._4

  let sellOrderId            = sellState._1
  let sellOrderFilled        = sellState._2
  let sellOrderRemaining     = sellState._3
  let sellOrderPriceAssetRem = sellState._4

  # Matched values
  let buyTrAddress  = buyTransfer._1
  let buyTrAmount   = buyTransfer._2
  let buyTrAsset    = buyTransfer._3
  let buyTrType     = buyTransfer._4
  let buyTrFeeType  = buyTransfer._5
  let buyTrFlags    = buyTransfer._6

  let sellTrAddress  = sellTransfer._1
  let sellTrAmount   = sellTransfer._2
  let sellTrAsset    = sellTransfer._3
  let sellTrType     = sellTransfer._4
  let sellTrFeeType  = sellTransfer._5
  let sellTrFlags    = sellTransfer._6

  strict checks = [
    # TODO: Enable after testing
    # i.callerPublicKey == matcherPublicKey || throwErr("permission denied"),
    !forceStop || throwErr("contract is temporary stopped"),
    buyTrAmount > 0 || throwErr("cannot send zero to buyer"),
    sellTrAmount > 0 || throwErr("cannot send zero to seller")
  ]

  let (buyOrderInternalId, buyOrderIdAction) = 
    if(isDefined(this.getInteger(keyOrderRemaining(buyOrderId))))
    then (O_COUNTER, nil)
    else (O_COUNTER+1, [StringEntry(keyInternalIdToOrderId(O_COUNTER+1), buyOrderId)])

  let (sellOrderInternalId, sellOrderIdAction) = 
    if(isDefined(this.getInteger(keyOrderRemaining(sellOrderId))))
    then (buyOrderInternalId, nil)
    else (buyOrderInternalId+1, [StringEntry(keyInternalIdToOrderId(buyOrderInternalId+1), sellOrderId)])

  let counterAction = 
    if(O_COUNTER != sellOrderInternalId) 
    then [IntegerEntry(keyIdCounter, sellOrderInternalId)]
    else nil

  let orderTypeContract = getOrderTypeContract(buyTrType).valueOrErrorMessage("order type contract error")
  let (buyTrFeeAsset, buyTrFee, sellTrFeeAsset, sellTrFee) = 
    if (buyTrFeeType == MAKER) 
    then (makerFeeAsset, makerFeeAmount, takerFeeAsset, takerFeeAmount) 
    else (takerFeeAsset, takerFeeAmount, makerFeeAsset, makerFeeAmount)

  strict exchange = [
    orderTypeContract.invoke(
      "exchange",
      [
        buyTrAddress.toString(),
        buyTrFeeType,
        buyTrFeeAsset,
        buyTrFee,
        sellTrAddress.toString(),
        sellTrFeeType,
        sellTrFeeAsset,
        sellTrFee,
        buyTrAmount,
        buyTrAsset.assetIdToString(),
        sellTrAmount,
        sellTrAsset.assetIdToString(),
        buyTrFlags,
        sellTrFlags
      ],
      []
    )
  ]

  # Set remaining amount to `0` if it's fully filled
  let (buyOrderStatusAction, buyOrderRealRemaining) = 
    if (buyOrderPriceAssetRem <= 0) 
    then ([IntegerEntry(keyOrderStatus(buyOrderId), O_FILLED)], 0)
    else (nil, buyOrderRemaining)

  let (sellOrderStatusAction, sellOrderRealRemaining) =
    if (sellOrderPriceAssetRem <= 0) 
    then ([IntegerEntry(keyOrderStatus(sellOrderId), O_FILLED)], 0) 
    else (nil, sellOrderRemaining)

  let updateOrderActions = [
    IntegerEntry(keyOrderRemaining(buyOrderId), buyOrderRealRemaining),
    IntegerEntry(keyOrderRemaining(sellOrderId), sellOrderRealRemaining)
  ]

  updateOrderActions ++ 
  buyOrderIdAction ++
  sellOrderIdAction ++
  counterAction ++
  buyOrderStatusAction ++
  sellOrderStatusAction
}