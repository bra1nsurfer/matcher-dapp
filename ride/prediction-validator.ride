{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"

let CONTRACT_NAME = "prediction-validator.ride"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

let PENDING       = "PENDING"
let WAVES         = "WAVES"
let wavesSignType = "waves-sign"
let ecdsaSignType = "ecdsa-sign"
let MAKER         = "maker"
let TAKER         = "taker"
let DEC8          = 1_0000_0000

# ORDER STATUS
let O_OPEN     = 0
let O_FILLED   = 1
let O_CANCELED = 2

# ORDER TYPE
let O_SPOT       = 0
let O_LEVERAGE   = 1
let O_MARGIN     = 2
let O_PREDICTION = 3

# ORDER DIRECTION
let ORDER_DIR_BUY  = "buy"
let ORDER_DIR_SELL = "sell"

# PREDICTION DIR
let P_DIR_YES = "yes"
let P_DIR_NO  = "no"

let kFactoryAddress = ["%s", "factoryAddress"].makeString(SEP)
let factoryAddressString = this.getString(kFactoryAddress).valueOrErrorMessage("factory address is not set")
let factoryAddress = factoryAddressString.addressFromString().valueOrErrorMessage("invalid factory address")

let kForceStop = ["%s", "forceStop"].makeString(SEP)
let forceStop  = factoryAddress.getBoolean(kForceStop).valueOrElse(false)

let kMatcherPublicKey = ["%s", "matcherPublicKey"].makeString(SEP)
let matcherPublicKey  = factoryAddress.getString(kMatcherPublicKey).valueOrElse("").fromBase58String()

let (NETWORK, CUR_TIMESTAMP) = match (blockInfoByHeight(height)) {
  case a:BlockInfo => (a.generator.bytes.drop(1).take(1), a.timestamp)
  case _ => throwErr("network byte error: block is not found")
}

let kAllowedAssets = ["%s", "allowedAssets"].makeString(SEP)
let allowedAssets  = match (factoryAddress.getString(kAllowedAssets)) {
    case s:String => s.split_4C(SEP)
    case _ => []  
  }

let kPredictionPriceAsset    = ["%s", "predictionPriceAsset"].makeString(SEP)
let predictionPriceAsset     = factoryAddress.getString(kPredictionPriceAsset).valueOrElse("prediction price asset is not set")
let predictionPriceAssetInfo = assetInfo(predictionPriceAsset.fromBase58String()).valueOrErrorMessage("prediction price asset is not found")
let PRICE_UNIT = pow(10, 0, predictionPriceAssetInfo.decimals, 0, 0, DOWN)

let keyIdCounter = ["%s", "counter"].makeString(SEP)
let O_COUNTER = this.getInteger(keyIdCounter).valueOrElse(0)

func keyInternalIdToOrderId(internalId: Int) = ["%s%d", "internalId", internalId.toString()].makeString(SEP)
func keyOrderRemaining(orderId: String)      = ["%s%s", "orderRemaining", orderId].makeString(SEP)
func keyOrderStatus(orderId: String)         = ["%s%s", "orderStatus", orderId].makeString(SEP)

func amountAssetToPriceAsset(amount: Int, price: Int) = {
  fraction(amount, price, 1, DOWN)
}

func priceAssetToAmountAsset(priceAssetAmount: Int, price: Int) = {
  fraction(priceAssetAmount, 1, price, CEILING)
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

func padBytes(x: ByteVector) = {
  let a = 0.toBytes()
  a + a.drop(x.size()) + x
}

func bytesToInt(x: ByteVector) = {
  x.padBytes().toBigInt().toInt()
}

func toUint256(n: ByteVector) = {
  # 32 zeroes
  let z = base58'11111111111111111111111111111111'
  let pad = z.drop(n.size())
  (pad + n)
}

func toShort(val: ByteVector) = (0.toBytes() + val).takeRight(2)
func getLenAsShort(val: ByteVector) = val.size().toBytes().takeRight(2)
func getBytesWithLen(val: ByteVector) = (val.getLenAsShort() + val)

func checkDirections(o1PredictionDir: String, o2PredictionDir: String, o1OrderDir: String, o2OrderDir: String) = {
  if (o1PredictionDir == o2PredictionDir) 
    then (o1OrderDir == ORDER_DIR_BUY && o2OrderDir == ORDER_DIR_SELL) || (o1OrderDir == ORDER_DIR_SELL && o2OrderDir == ORDER_DIR_BUY)
    else (o1OrderDir == ORDER_DIR_BUY && o2OrderDir == ORDER_DIR_BUY) || (o1OrderDir == ORDER_DIR_SELL && o2OrderDir == ORDER_DIR_SELL)
}

func getEipOrderDataHashV1(orderId: String) = {
  ### EIP-712
  ### ABI encoding

  # Constant prefix [25, 1]
  let prefix = base58'2uN'

  ### Domain typed data
  ###
  let domainType = "EIP712Domain(uint256 chainId)".toBytes().keccak256()
  let domainValue = NETWORK.toUint256()
  let domain = keccak256(domainType + domainValue)

  ### Message typed data
  ###
  let messageType = "Message(string text)".toBytes().keccak256()
  let messageValue = orderId.toBytes().keccak256()
  let message = keccak256(messageType + messageValue)

  keccak256(prefix + domain + message)
}

func getEipOrderDataHashV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      )) = {
  let (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  ) = orderData

  ### EIP-712
  ### ABI encoding

  # Constant prefix [25, 1]
  let prefix = base58'2uN'

  ### Domain typed data
  ###
  let domainType = "EIP712Domain(uint256 chainId)".toBytes().keccak256()
  let domainValue = NETWORK.toUint256()
  let domain = keccak256(domainType + domainValue)

  ### Message typed data
  ###
  let messageType     = "TypedData(int64 version,string network,string sender,string matcherPublicKey,string amountAssetId,string priceAssetId,int64 orderType,string orderDirection,int64 amount,int64 price,int64 timestamp,int64 expiration,int64 flags)".toBytes().keccak256()
  let versionHash     = 2.toBytes().toUint256()
  let networkHash     = networkByte.keccak256()
  let senderHash      = senderBytes.toBase58String().toBytes().keccak256()
  let matcherHash     = matcherPublicKey.toBase58String().toBytes().keccak256()
  let amountAssetHash = amountAsset.assetIdToString().toBytes().keccak256()
  let priceAssetHash  = priceAsset.assetIdToString().toBytes().keccak256()
  let orderTypeHash   = orderType.toBytes().toUint256()
  let orderDirHash    = orderDir.toBytes().keccak256()
  let amountHash      = amount.toBytes().toUint256()
  let priceHash       = price.toBytes().toUint256()
  let timestampHash   = timestamp.toBytes().toUint256()
  let expirationHash  = expiration.toBytes().toUint256()
  let flagsHash       = flags.toUint256()

  let message = keccak256(
    messageType + 
    versionHash +
    networkHash +
    senderHash +
    matcherHash +
    amountAssetHash +
    priceAssetHash +
    orderTypeHash +
    orderDirHash +
    amountHash +
    priceHash +
    timestampHash +
    expirationHash +
    flagsHash
    )


  keccak256(prefix + domain + message)
}

func getOrderBytesV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      )) = {
  let (
    networkByte,
    pubKeyType,
    senderBytes,
    matcherBytes,
    amountAsset,
    priceAsset,
    orderType,
    orderDir,
    amount,
    price,
    timestamp,
    expiration,
    flags
  ) = orderData

  # Signer padding V2
  # Prefix: [255, 255, 255, 2]
  let prefix = base58'7YXq4u'

  let LONG    = 0.toBytes().takeRight(1)
  let BOOLEAN = 1.toBytes().takeRight(1)
  let BYTES   = 2.toBytes().takeRight(1)
  let STRING  = 3.toBytes().takeRight(1)

  let versionKey   = "version".toBytes()
  let versionValue = 2.toBytes()

  let networkKey   = "network".toBytes()
  let networkValue = networkByte

  let senderKey   = "sender".toBytes()
  let senderValue = senderBytes.toBase58String().toBytes()

  let matcherKey   = "matcherPublicKey".toBytes()
  let matcherValue = matcherBytes.toBase58String().toBytes()

  let amountAssetKey = "amountAssetId".toBytes()
  let amountAssetValue = amountAsset.assetIdToString().toBytes()

  let priceAssetKey   = "priceAssetId".toBytes()
  let priceAssetValue = priceAsset.assetIdToString().toBytes()

  let orderTypeKey   = "orderType".toBytes()
  let orderTypeValue = orderType.toBytes()

  let orderDirKey   = "orderDirection".toBytes()
  let orderDirValue = orderDir.toBytes()

  let amountKey   = "amount".toBytes()
  let amountValue = amount.toBytes()

  let priceKey   = "price".toBytes()
  let priceValue = price.toBytes()

  let timestampKey   = "timestamp".toBytes()
  let timestampValue = timestamp.toBytes()

  let expirationKey   = "expiration".toBytes()
  let expirationValue = expiration.toBytes()

  let flagsKey   = "flags".toBytes()
  let flagsValue = flags

  prefix + 13.toBytes().toShort() + # 13 - amount of fields in order
  versionKey.getBytesWithLen() + LONG + versionValue +
  networkKey.getBytesWithLen() + STRING + networkValue.getBytesWithLen() +
  senderKey.getBytesWithLen() + STRING + senderValue.getBytesWithLen() +
  matcherKey.getBytesWithLen() + STRING + matcherValue.getBytesWithLen() +
  amountAssetKey.getBytesWithLen() + STRING + amountAssetValue.getBytesWithLen() +
  priceAssetKey.getBytesWithLen() + STRING + priceAssetValue.getBytesWithLen() +
  orderTypeKey.getBytesWithLen() + LONG + orderTypeValue +
  orderDirKey.getBytesWithLen() + STRING + orderDirValue.getBytesWithLen() +
  amountKey.getBytesWithLen() + LONG + amountValue +
  priceKey.getBytesWithLen() + LONG + priceValue +
  timestampKey.getBytesWithLen() + LONG + timestampValue +
  expirationKey.getBytesWithLen() + LONG + expirationValue +
  flagsKey.getBytesWithLen() + LONG + flagsValue
}

func checkSignV1(orderId: String, proof: ByteVector, pubKey: (String, ByteVector)) = {
  let (pubKeyType, senderBytes) = pubKey

  let wavesCheck = if (pubKeyType == wavesSignType) 
    then {
      # Signer padding 
      # Prefix: [255, 255, 255, 1]
      let prefix = base58'7YXq4t'
      let orderIdBytes = prefix + orderId.toBytes()
      (sigVerify(orderIdBytes, proof, senderBytes))
    }
    else false
  let ecdsaCheck = if (pubKeyType == ecdsaSignType) 
    then {
      let address = Address(senderBytes)
      let orderDataHash = getEipOrderDataHashV1(orderId)
      (ecrecover(orderDataHash, proof).addressFromPublicKey() == address)
    }
    else false
  
  wavesCheck || ecdsaCheck
}

func checkSignV2(
    orderData: 
      (
        ByteVector, 
        String, 
        ByteVector, 
        ByteVector, 
        ByteVector|Unit, 
        ByteVector|Unit, 
        Int, 
        String, 
        Int, 
        Int, 
        Int, 
        Int, 
        ByteVector
      ),
    proof: ByteVector, 
    pubKey: (String, ByteVector)) = {
  let (pubKeyType, senderBytes) = pubKey
  let wavesCheck = if (pubKeyType == wavesSignType) 
    then {
      let signedBytes = getOrderBytesV2(orderData)
      (sigVerify(signedBytes, proof, senderBytes))
    }
    else false
  let ecdsaCheck = if (pubKeyType == ecdsaSignType) 
    then {
      let address = Address(senderBytes)
      let orderDataHash = getEipOrderDataHashV2(orderData)
      (ecrecover(orderDataHash, proof).addressFromPublicKey() == address)
    }
    else false
  
  wavesCheck || ecdsaCheck
}

func parseOrderV1(orderBytes: ByteVector) = {
  let networkByte = orderBytes.drop(1).take(1)
  let data1 = orderBytes.drop(2)
  
  # Waves pubKey or address (EIP-712)
  let senderFlag = data1.take(1).bytesToInt()
  let data2 = data1.drop(1)
  let (senderBytesLen, pubKeyType) = if(senderFlag == 0) 
    then (32, wavesSignType) 
    else (26, ecdsaSignType)
  let senderBytes = data2.take(senderBytesLen)
  let data3 = data2.drop(senderBytesLen)

  let matcherBytesLen = 32
  let matcherBytes = data3.take(matcherBytesLen)
  let data4 = data3.drop(matcherBytesLen)

  let amountAssetFlag = data4.take(1).bytesToInt()
  let data5 = data4.drop(1)
  let amountAssetLen = if(amountAssetFlag == 0) then 0 else 32
  let amountAsset = if(amountAssetLen == 0) then unit else data5.take(amountAssetLen)
  let data6 = data5.drop(amountAssetLen)

  let priceAssetFlag = data6.take(1).bytesToInt()
  let data7 = data6.drop(1)
  let priceAssetLen = if(priceAssetFlag == 0) then 0 else 32
  let priceAsset = if(priceAssetLen == 0) then unit else data7.take(priceAssetLen)
  let data8 = data7.drop(priceAssetLen)

  let orderType = data8.take(1).bytesToInt()
  let data9 = data8.drop(1)

  let orderDirByte = data9.take(1).bytesToInt()
  let orderDir = if (orderDirByte == 0) then ORDER_DIR_BUY else ORDER_DIR_SELL
  let data10 = data9.drop(1)

  let amount = data10.take(8).bytesToInt()
  let data11 = data10.drop(8)

  let price = data11.take(8).bytesToInt()
  let data12 = data11.drop(8)

  let timestamp = data12.take(8).bytesToInt()
  let data13 = data12.drop(8)
  
  let expiration = data13.take(8).bytesToInt()
  let data14 = data13.drop(8)

  let flags = data14.take(8)

  let (p_dir, realPrice) = if (flags.takeRight(1).bytesToInt() == 1) then (P_DIR_NO, PRICE_UNIT-price) else (P_DIR_YES, price)
  
  (
    (
      networkByte,
      pubKeyType,
      senderBytes,
      matcherBytes,
      amountAsset,
      priceAsset,
      orderType,
      orderDir,
      amount,
      price,
      timestamp,
      expiration,
      flags
    ),
    p_dir,
    realPrice
  )
}

func parseOrder(orderBytes: ByteVector, proof: ByteVector) = {
  let version = orderBytes.take(1).bytesToInt()

  let (orderData, p_dir, realPrice) = if (version == 1 || version == 2) 
    then parseOrderV1(orderBytes) 
    else throwErr("order version is not supported")
  let orderId = sha256(orderBytes).toBase58String()
  let orderStatus = this.getInteger(keyOrderStatus(orderId)).valueOrElse(O_OPEN)
  let (pubKeyType, pubKey) = (orderData._2, orderData._3)
  
  let signCheck = if (version == 1) 
    then checkSignV1(orderId, proof, (pubKeyType, pubKey))
    else if (version == 2) 
      then checkSignV2(orderData, proof, (pubKeyType, pubKey))
      else false

  strict check = [
    signCheck || throwErr(["order proof is not valid ", orderId].makeString(" "))
  ]

  (orderData, orderId, orderStatus, p_dir, realPrice)
}

func getRemainingAmount(orderId: String, fullAmount: Int) = {
  let remainingAmount = this.getInteger(keyOrderRemaining(orderId)).valueOrElse(fullAmount)
  let filled = max([fullAmount - remainingAmount, 0])

  (remainingAmount, filled)
}

func matchOrders(
  o1Bytes       : ByteVector,
  o1proof       : ByteVector,
  o2Bytes       : ByteVector,
  o2proof       : ByteVector,
  matchAmount   : Int,
  matchPrice    : Int,
  makerFeeAsset : String,
  makerFeeAmount: Int,
  takerFeeAsset : String,
  takerFeeAmount: Int
  ) = {

  ### parseOrder._1 struct
  #   ._1  networkByte,
  #   ._2  pubKeyType,
  #   ._3  senderBytes,
  #   ._4  matcherBytes,
  #   ._5  amountAsset,
  #   ._6  priceAsset,
  #   ._7  orderType,
  #   ._8  orderDirection,
  #   ._9  amount,
  #   ._10 price,
  #   ._11 timestamp (nonce)
  #   ._12 expiration | 0
  #   ._13 flags
  let o1 = parseOrder(o1Bytes, o1proof)
  let o2 = parseOrder(o2Bytes, o2proof)

  let (order1, makerOrderId, makerStatus, makerPredDir, makerRealPrice) = o1
  let (order2, takerOrderId, takerStatus, takerPredDir, takerRealPrice) = o2

  let makerNetwork      = order1._1
  let makerPubKeyType   = order1._2
  let makerSenderBytes  = order1._3
  let makerMatcherBytes = order1._4
  let makerEventId      = order1._5
  let makerPriceAsset   = order1._6
  let makerType         = order1._7
  let makerDir          = order1._8
  let makerFullAmount   = order1._9
  let makerPrice        = makerRealPrice
  let makerNonce        = order1._11
  let makerExpiration   = order1._12
  let makerFlags        = order1._13
  
  let takerNetwork      = order2._1
  let takerPubKeyType   = order2._2
  let takerSenderBytes  = order2._3
  let takerMatcherBytes = order2._4
  let takerEventId      = order2._5
  let takerPriceAsset   = order2._6
  let takerType         = order2._7
  let takerDir          = order2._8
  let takerFullAmount   = order2._9
  let takerPrice        = takerRealPrice
  let takerNonce        = order2._11
  let takerExpiration   = order2._12
  let takerFlags        = order2._13

  strict validation = [
    (makerNetwork == NETWORK && takerNetwork == NETWORK) || throwErr("network byte is not valid"),
    (makerMatcherBytes == matcherPublicKey) || throwErr("maker order matcher bytes does not match"),
    (takerMatcherBytes == matcherPublicKey) || throwErr("taker order matcher bytes does not match"),
    (makerEventId == takerEventId) || throwErr("event Id does not match"),
    (makerEventId != unit) || throwErr("invalid event id"),
    (makerPriceAsset == takerPriceAsset) || throwErr("price asset Id does not match"),
    (makerPrice <= PRICE_UNIT && makerPrice > 0) || throwErr("invalid maker order price"),
    (takerPrice <= PRICE_UNIT && takerPrice > 0) || throwErr("invalid taker order price"),
    (makerExpiration == 0 || makerExpiration >= CUR_TIMESTAMP) || throwErr("maker order is expired"),
    (takerExpiration == 0 || takerExpiration >= CUR_TIMESTAMP) || throwErr("taker order is expired"),
    (makerStatus == O_OPEN) || throwErr("maker order is closed"),
    (takerStatus == O_OPEN) || throwErr("taker order is closed"),
    (makerOrderId != takerOrderId) || throwErr("maker order and taker order are the same"),
    (allowedAssets.containsElement(makerPriceAsset.assetIdToString())) || throwErr("price asset not in the allowed list"),
    (makerType == O_PREDICTION) || throwErr("maker order type must be prediction"),
    (takerType == O_PREDICTION) || throwErr("taker order type must be prediction"),
    !(makerPredDir == takerPredDir && makerDir == takerDir) || throwErr("invalid prediction and order direction"),
    (matchPrice <= makerPrice) || throwErr("match price is higher than maker price"),
    (matchPrice <= takerPrice) || throwErr("match price is higher than taker price")
  ]

  let makerSenderAddress = 
    if(makerPubKeyType == ecdsaSignType) 
    then Address(makerSenderBytes) 
    else addressFromPublicKey(makerSenderBytes)
  let takerSenderAddress = 
    if(takerPubKeyType == ecdsaSignType) 
    then Address(takerSenderBytes) 
    else addressFromPublicKey(takerSenderBytes)

  let (makerRawRemaining, _makerFilled) = getRemainingAmount(makerOrderId, makerFullAmount)
  let (takerRawRemaining, _takerFilled) = getRemainingAmount(takerOrderId, takerFullAmount)

  # If order fee asset is the same as order sending asset
  # decrease order amount by fee
  let makerOrderRemaining = 
    if (makerPriceAsset.assetIdToString() == makerFeeAsset) 
    then (makerRawRemaining - priceAssetToAmountAsset(makerFeeAmount, makerPrice)) 
    else makerRawRemaining
  let takerOrderRemaining = 
    if (takerPriceAsset.assetIdToString() == takerFeeAsset)
    then (takerRawRemaining - priceAssetToAmountAsset(takerFeeAmount, takerPrice))
    else takerRawRemaining

  # If matchAmount is set to `-1`, match orders with maximum available amount
  let realMatchAmount = if (matchAmount == -1) then min([makerOrderRemaining, takerOrderRemaining]) else matchAmount

  strict check2 = [
    realMatchAmount >= 0 || "cannot match negative amount".throwErr(),
    realMatchAmount <= makerOrderRemaining || ["matched amount exceeds maker order remaining amount (", makerOrderRemaining.toString(), ")"].makeString("").throwErr(),
    realMatchAmount <= takerOrderRemaining || ["matched amount exceeds taker order remaining amount (", takerOrderRemaining.toString(), ")"].makeString("").throwErr()
  ]

  let matchAmountInPriceAsset = amountAssetToPriceAsset(realMatchAmount, matchPrice)

  let newMakerRemaining  = makerOrderRemaining - realMatchAmount
  let newTakerRemaining = takerOrderRemaining - realMatchAmount

  let newMakerFilled  = makerFullAmount - newMakerRemaining
  let newTakerFilled = takerFullAmount - newTakerRemaining

  # Convert remaining amount to price asset at order price
  let makerPriceAssetRem = amountAssetToPriceAsset(newMakerRemaining, makerPrice)
  let takerPriceAssetRem = amountAssetToPriceAsset(newTakerRemaining, takerPrice)

  let makerFinalEventId = [makerEventId.assetIdToString(), makerPredDir].makeString("-")
  let makerFinalPriceAmount = if (makerPredDir == P_DIR_YES)
    then matchAmountInPriceAsset
    else amountAssetToPriceAsset(realMatchAmount, PRICE_UNIT-matchPrice)

  let takerFinalEventId = [takerEventId.assetIdToString(), takerPredDir].makeString("-")
  let takerFinalPriceAmount = if (takerPredDir == P_DIR_YES)
    then matchAmountInPriceAsset
    else amountAssetToPriceAsset(realMatchAmount, PRICE_UNIT-matchPrice)

  (
    (makerSenderAddress, realMatchAmount, makerFinalEventId, makerFinalPriceAmount, makerPriceAsset, makerDir, makerFlags),
    (takerSenderAddress, realMatchAmount, takerFinalEventId, takerFinalPriceAmount, takerPriceAsset, takerDir, takerFlags),
    (makerOrderId, newMakerFilled, newMakerRemaining, makerPriceAssetRem), 
    (takerOrderId, newTakerFilled, newTakerRemaining, takerPriceAssetRem)
  )
}

func getOrderTypeContract(orderType: Int) = {
  let addressString = factoryAddress.invoke("getOrderTypeContract", [orderType], [])
  
  match (addressString) {
      case s:String => s.addressFromString()
      case _ => unit
    }
}

# o1 - Maker
# o2 - Taker
@Callable(i)
func validateAndExchange(
  o1bytes       : ByteVector,
  o1proof       : ByteVector,
  o2bytes       : ByteVector,
  o2proof       : ByteVector,
  matchAmount   : Int,
  matchPrice    : Int,
  makerFeeAsset : String,
  makerFeeAmount: Int,
  takerFeeAsset : String,
  takerFeeAmount: Int
  ) = {
  
  let (makerTransfer, takerTransfer, makerOrderState, takerOrderState) = 
    matchOrders(
      o1bytes, 
      o1proof, 
      o2bytes, 
      o2proof, 
      matchAmount, 
      matchPrice, 
      makerFeeAsset,
      makerFeeAmount,
      takerFeeAsset,
      takerFeeAmount
    )

  # Order state
  let makerOrderId            = makerOrderState._1
  let makerOrderFilled        = makerOrderState._2
  let makerOrderRemaining     = makerOrderState._3
  let makerOrderPriceAssetRem = makerOrderState._4

  let takerOrderId            = takerOrderState._1
  let takerOrderFilled        = takerOrderState._2
  let takerOrderRemaining     = takerOrderState._3
  let takerOrderPriceAssetRem = takerOrderState._4

  # Matched values
  let makerAddress     = makerTransfer._1
  let makerMatchAmount = makerTransfer._2
  let makerEventId     = makerTransfer._3
  let makerPriceAmount = makerTransfer._4
  let makerPriceAsset  = makerTransfer._5
  let makerDir         = makerTransfer._6
  let makerFlags       = makerTransfer._7

  let takerAddress     = takerTransfer._1
  let takerMatchAmount = takerTransfer._2
  let takerEventId     = takerTransfer._3
  let takerPriceAmount = takerTransfer._4
  let takerPriceAsset  = takerTransfer._5
  let takerDir         = takerTransfer._6
  let takerFlags       = takerTransfer._7

  strict checks = [
    # TODO: Enable after testing
    # i.callerPublicKey == matcherPublicKey || throwErr("permission denied"),
    !forceStop || throwErr("contract is temporary stopped"),
    makerMatchAmount > 0 || throwErr("maker match amount must be positive"),
    makerPriceAmount > 0 || throwErr("maker match price amount must be positive"),
    takerMatchAmount > 0 || throwErr("taker match amount must be positive"),
    takerPriceAmount > 0 || throwErr("taker match price amount must be positive")
  ]

  let (makerOrderInternalId, makerOrderIdAction) = 
    if(isDefined(this.getInteger(keyOrderRemaining(makerOrderId))))
    then (O_COUNTER, nil)
    else (O_COUNTER+1, [StringEntry(keyInternalIdToOrderId(O_COUNTER+1), makerOrderId)])

  let (takerOrderInternalId, takerOrderIdAction) = 
    if(isDefined(this.getInteger(keyOrderRemaining(takerOrderId))))
    then (makerOrderInternalId, nil)
    else (makerOrderInternalId+1, [StringEntry(keyInternalIdToOrderId(makerOrderInternalId+1), takerOrderId)])

  let counterAction = 
    if(O_COUNTER != takerOrderInternalId) 
    then [IntegerEntry(keyIdCounter, takerOrderInternalId)]
    else nil

  let predictionContract = getOrderTypeContract(O_PREDICTION).valueOrErrorMessage("order type contract error")

  strict exchange = [
    predictionContract.invoke(
      "exchange",
      [
        makerAddress.toString(),
        makerFeeAsset,
        makerFeeAmount,
        makerMatchAmount,
        makerEventId,
        makerPriceAmount,
        makerPriceAsset.assetIdToString(),
        makerDir,
        makerFlags,

        takerAddress.toString(),
        takerFeeAsset,
        takerFeeAmount,
        takerMatchAmount,
        takerEventId,
        takerPriceAmount,
        takerPriceAsset.assetIdToString(),
        takerDir,
        takerFlags
      ],
      []
    )
  ]

  # Set remaining amount to `0` if it's fully filled
  let (makerOrderStatusAction, makerOrderRealRemaining) = 
    if (makerOrderPriceAssetRem <= 0) 
    then ([IntegerEntry(keyOrderStatus(makerOrderId), O_FILLED)], 0)
    else (nil, makerOrderRemaining)

  let (takerOrderStatusAction, takerOrderRealRemaining) =
    if (takerOrderPriceAssetRem <= 0) 
    then ([IntegerEntry(keyOrderStatus(takerOrderId), O_FILLED)], 0) 
    else (nil, takerOrderRemaining)

  let updateOrderActions = [
    IntegerEntry(keyOrderRemaining(makerOrderId), makerOrderRealRemaining),
    IntegerEntry(keyOrderRemaining(takerOrderId), takerOrderRealRemaining)
  ]

  updateOrderActions ++ 
  makerOrderIdAction ++
  takerOrderIdAction ++
  counterAction ++
  makerOrderStatusAction ++
  takerOrderStatusAction
}