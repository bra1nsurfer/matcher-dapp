{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP           = "__"
let CONTRACT_NAME = "legacy-prediction.ride"
let WAVES         = "WAVES"
let DEC8          = 1_0000_0000

# EVENT STATUS
let E_NOT_FOUND  = -1
let E_OPEN       = 0
let E_CLOSED_YES = 1
let E_CLOSED_NO  = 2
let E_STOPPED    = 3
let E_EXPIRED    = 4
let E_REJECTED   = 5

### Do not forget to update `FOLD<>` in mass creation functions
let INDEXES = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
let MAX_FOLD_EVENTS = INDEXES.size()

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

func assetIdToString(assetId: ByteVector|Unit) = {
  match assetId {
    case b: ByteVector => b.toBase58String()
    case _: Unit => WAVES
  }
}

func stringToAssetId(s: String) = {
  if (s == WAVES) then unit else s.fromBase58String()
}

let currentDatetime = match (blockInfoByHeight(height)) {
    case bi:BlockInfo => bi.timestamp
    case _ => 0
  }

let kForceStop = ["%s", "forceStop"].makeString(SEP)
let forceStop  = this.getBoolean(kForceStop).valueOrElse(false)

let kEventCreationFeeAmount  = ["%s", "eventCreationFeeAmount"].makeString(SEP)
let eventCreationFeeAmount   = this.getInteger(kEventCreationFeeAmount).valueOrElse(0)
let kGroupCreationFeeAmount  = ["%s", "groupCreationFeeAmount"].makeString(SEP)
let groupCreationFeeAmount   = this.getInteger(kGroupCreationFeeAmount).valueOrElse(0)
let kEventMinFeeRate         = ["%s", "mintFeeRate"].makeString(SEP)
let eventMintFeeRate         = this.getInteger(kEventMinFeeRate).valueOrElse(0)
let kPredictionPriceAsset    = ["%s", "predictionPriceAsset"].makeString(SEP)
let sPredictionPriceAsset    = this.getString(kPredictionPriceAsset).valueOrElse("prediction price asset is not set")
let predictionPriceAsset     = sPredictionPriceAsset.stringToAssetId()
let predictionPriceAssetInfo = assetInfo(sPredictionPriceAsset.fromBase58String()).valueOrErrorMessage("prediction price asset is not found")
# Calc price asset single token decimals or DEC8 for Waves
let PREDICTION_PRICE_UNIT = match (predictionPriceAsset) {
    case t:ByteVector => pow(10, 0, predictionPriceAssetInfo.decimals, 0, 0, DOWN)
    case _ => DEC8
  }

let kLastEventIndex = ["%s", "lastEventIndex"].makeString(SEP)
let lastEventIndex  = this.getInteger(kLastEventIndex).valueOrElse(0)

let kLastGroupIndex = ["%s", "lastGroupIndex"].makeString(SEP)
let lastGroupIndex = this.getInteger(kLastGroupIndex).valueOrElse(0)

let kEventAdminList = ["%s", "eventAdminList"].makeString(SEP)
let eventAdminList  = match (this.getString(kEventAdminList)) {
    case str:String => str.split(SEP)
    case _ => []
  }

let kFeeGetter = ["%s", "feeGetter"].makeString(SEP)
let sFeeGetter = this.getString(kFeeGetter).valueOrElse(this.toString())
let feeGetter  = sFeeGetter.addressFromStringValue()

let kMaxEventsInGroup = ["%s", "maxEventsInGroup"].makeString(SEP)
let MAX_GROUP_EVENTS  = this.getInteger(kMaxEventsInGroup).valueOrElse(20)

func kEventName(eventId: String)         = ["%s%s%d", "event", "name", eventId].makeString(SEP)
func kEventEndDatetime(eventId: String)  = ["%s%s%d", "event", "endDatetime", eventId].makeString(SEP)
func kEventStatus(eventId: String)       = ["%s%s%d", "event", "status", eventId].makeString(SEP)
func kEventYesAssetId(eventId: String)   = ["%s%s%d", "event", "yesAssetId", eventId].makeString(SEP)
func kEventNoAssetId(eventId: String)    = ["%s%s%d", "event", "noAssetId", eventId].makeString(SEP)
func kEventTokensMinted(eventId: String) = ["%s%s%d", "event", "tokensMinted", eventId].makeString(SEP)
func kEventGroupId(eventId: String)      = ["%s%s%d", "event", "groupId", eventId].makeString(SEP)
func kEventCreator(eventId: String)      = ["%s%s%d", "event", "creator", eventId].makeString(SEP)

func kGroupName(groupId: String)          = ["%s%s%d", "group", "name", groupId].makeString(SEP)
func kGroupDesc(groupId: String)          = ["%s%s%d", "group", "description", groupId].makeString(SEP)
func kGroupImgSrc(groupId: String)        = ["%s%s%d", "group", "imgSrc", groupId].makeString(SEP)
func kGroupSource(groupId: String)        = ["%s%s%d", "group", "source", groupId].makeString(SEP)
func kGroupCreator(groupId: String)       = ["%s%s%d", "group", "creator", groupId].makeString(SEP)
func kGroupCategory(groupId: String)      = ["%s%s%d", "group", "category", groupId].makeString(SEP)
func kGroupEvents(groupId: String)        = ["%s%s%d", "group", "events", groupId].makeString(SEP)
func kGroupRejectedCount(groupId: String) = ["%s%s%d", "group", "rejectedCount", groupId].makeString(SEP)

func getGroupEvents(groupId: String) = match (this.getString(kGroupEvents(groupId))) {
    case str:String => str.split_51C(SEP)
    case _ => []
  }

func getEventStatus(eventId: String) = {
  match (this.getInteger(kEventStatus(eventId))) {
      case STATUS:Int => {
        let endDatetime = this.getInteger(kEventEndDatetime(eventId)).valueOrElse(0)
        if (STATUS == E_OPEN && endDatetime < currentDatetime) then E_EXPIRED else STATUS
      }
      case _ => E_NOT_FOUND
    }
}

func getRejectedCount(groupId: String) = this.getInteger(kGroupRejectedCount(groupId)).valueOrElse(0)

func amountAssetToPriceAsset(amount: Int, price: Int) = {
  fraction(amount, price, 1, DOWN)
}

func priceAssetToAmountAsset(priceAssetAmount: Int, price: Int) = {
  fraction(priceAssetAmount, 1, price, DOWN)
}

func keyManagerPublicKey() = "%s__managerPublicKey"
func keyManagerVaultAddress() = "%s__managerVaultAddress"

func getManagerVaultAddressOrThis() = {
  match keyManagerVaultAddress().getString() {
    case s:String => s.addressFromStringValue()
    case _=> this
  }
}

func managerPublicKeyOrUnit() = {
  let managerVaultAddress = getManagerVaultAddressOrThis()
  match managerVaultAddress.getString(keyManagerPublicKey()) {
    case s: String => s.fromBase58String()
    case _: Unit => unit
  }
}

func isAdmin(callerAddress: String) = {
  let targetAddress = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk.addressFromPublicKey()
    case _: Unit => this
  }

  callerAddress == targetAddress.toString()
}

func isEventAdmin(callerAddress: String) = {
  isAdmin(callerAddress) || eventAdminList.containsElement(callerAddress)
}

func editGroupHelper(groupId: String, name: String, description: String, category: String, imgSrc: String, source: String, creator: String) = {
  let nameEntry     = if(name.size() > 0)        then [StringEntry(kGroupName(groupId), name)] else []
  let descEntry     = if(description.size() > 0) then [StringEntry(kGroupDesc(groupId), description)] else []
  let categoryEntry = if(category.size() > 0)    then [StringEntry(kGroupCategory(groupId), category)] else []
  let imgEntry      = if(imgSrc.size() > 0)      then [StringEntry(kGroupImgSrc(groupId), imgSrc)] else []
  let sourceEntry   = if(source.size() > 0)      then [StringEntry(kGroupSource(groupId), source)] else []
  let creatorEntry  = if(creator.size() > 0)     then [StringEntry(kGroupCreator(groupId), creator)] else []

  nameEntry ++ 
  descEntry ++ 
  categoryEntry ++ 
  imgEntry ++ 
  sourceEntry ++ 
  creatorEntry
}

func editEventInfoHelper(eventId: String, groupId: String, name: String, endDatetime: Int, creator: String) = {
  let nameEntry    = if(name.size() > 0)    then [StringEntry(kEventName(eventId), name)] else []
  let endEntry     = if(endDatetime != 0)   then [IntegerEntry(kEventEndDatetime(eventId), endDatetime)] else []
  let groupEntry   = if(groupId.size() > 0) then [StringEntry(kEventGroupId(eventId), groupId)] else []
  let creatorEntry = if(creator.size() > 0) then [StringEntry(kEventCreator(eventId), creator)] else []

  nameEntry ++ 
  endEntry ++ 
  creatorEntry ++
  groupEntry
}

# Change groupId for event
# Update list of events for old and new group
func eventGroupIdHelper(eventId: String, groupId: String) = {
  let oldGroupId = this.getString(kEventGroupId(eventId)).valueOrElse("NULL")
  let prevGroupActions = if(groupId == oldGroupId || oldGroupId == "NULL" || groupId.size() == 0)
    then []
    else {
      let prevGroupOldEvents = getGroupEvents(oldGroupId)
      let prevGroupNewEvents = match(prevGroupOldEvents.indexOf(eventId)) {
        case ind:Int => prevGroupOldEvents.removeByIndex(ind)
        case _ => prevGroupOldEvents
      }
      let prevGroupAction = if(prevGroupNewEvents.size() > 0)
        then StringEntry(kGroupEvents(oldGroupId), prevGroupNewEvents.makeString(SEP))
        else DeleteEntry(kGroupEvents(oldGroupId))

      [prevGroupAction]
    }
  let nextGroupEvents = getGroupEvents(groupId) :+ eventId
  let nextGroupActions = if(groupId.size() != 0 && groupId != oldGroupId) 
    then [StringEntry(kGroupEvents(groupId), nextGroupEvents.makeString(SEP))] 
    else []

  let oldGroupRejected = getRejectedCount(oldGroupId)
  let newGroupRejected = getRejectedCount(groupId)
  let eventStatus = getEventStatus(eventId)

  let rejectedCountActions = if (eventStatus == E_REJECTED && groupId != oldGroupId)
    then [
      IntegerEntry(kGroupRejectedCount(oldGroupId), oldGroupRejected - 1),
      IntegerEntry(kGroupRejectedCount(groupId), newGroupRejected + 1)
    ]
    else []

  prevGroupActions ++ 
  nextGroupActions ++
  rejectedCountActions
}

func editEventHelper(eventId: String, groupId: String, name: String, endDatetime: Int, creator: String) = {
  let infoActions = editEventInfoHelper(eventId, groupId, name, endDatetime, creator)
  let groupIdActions = eventGroupIdHelper(eventId, groupId)

  infoActions ++ groupIdActions
}

func eventTokensActions(eventId: String) = {
  let yesAssetName = ["EV", eventId, "Y"].makeString("_")
  let yesAssetDesc = ["EventId:", eventId, "YES token"].makeString(" ")
  let yesAssetIssue = Issue(yesAssetName, yesAssetDesc, 0, 0, true)
  let yesAssetId = calculateAssetId(yesAssetIssue)

  let noAssetName = ["EV", eventId, "N"].makeString("_")
  let noAssetDesc = ["EventId:", eventId, "NO token"].makeString(" ")
  let noAssetIssue = Issue(noAssetName, noAssetDesc, 0, 0, true)
  let noAssetId = calculateAssetId(noAssetIssue)

  [
    StringEntry(kEventYesAssetId(eventId), yesAssetId.assetIdToString()),
    StringEntry(kEventNoAssetId(eventId), noAssetId.assetIdToString()),
    IntegerEntry(kEventTokensMinted(eventId), 0),
    yesAssetIssue,
    noAssetIssue
  ]
}

func massEventHelper(
    acc: (
      (
        String,
        String,
        Int,
        List[String],
        List[String]
      ),
      List[String],
      List[StringEntry|IntegerEntry],
      Int
    ), 
    arrInd: Int
  ) = {
  let (CONST_DATA, eventIds, actions, localLastIndex) = acc
  let (groupId, creator, eNamesCount, eNamesList, eEndList) = CONST_DATA

  if (arrInd < eNamesCount) then {
    let localEventIdInt = localLastIndex + 1
    let localEventId = localEventIdInt.toString()
    let endDatetime = eEndList[arrInd].parseInt().valueOrErrorMessage("massAddEvent: cannot parse timestamp")

    strict localCheck = [
      endDatetime > currentDatetime || throwErr(["wrong end date. Now:", currentDatetime.toString()].makeString(" "))
    ]

    let infoActions = editEventInfoHelper(localEventId, groupId, eNamesList[arrInd], endDatetime, creator)
    let tokensActions = eventTokensActions(localEventId)

    (
      CONST_DATA,
      eventIds :+ localEventId,
      actions ++ infoActions ++ tokensActions, 
      localEventIdInt
    )
  }
  else acc
}

func massNewEventsHelper(
  creator      : String,
  groupId      : String,
  eNames       : String,
  eEndDatetimes: String
) = {
  let eNamesList = eNames.split_51C(SEP)
  let eNamesCount = eNamesList.size()
  let eEndList = eEndDatetimes.split_51C(SEP)
  let eEndCount = eEndList.size()

  let eTotalFee = eventCreationFeeAmount * eNamesCount

  strict check = [
    eNames.size() > 0 || throwErr("event cannot be empty"),
    eEndDatetimes.size() > 0 || throwErr("event end datetimes cannot be empty"),
    eNamesCount <= MAX_FOLD_EVENTS || throwErr("too many events"),
    eNamesCount == eEndCount || throwErr("invalid events end datetime amount")
  ]

  ### Main `FOLD<>`
  let CONST_DATA = (groupId, creator, eNamesCount, eNamesList, eEndList)
  let (_a, groupEventIds, allEventsActions, newLastEventIndex) = FOLD<10>(INDEXES, (CONST_DATA, [], [], lastEventIndex), massEventHelper)
  ###

  let groupEventIdsActions = [StringEntry(kGroupEvents(groupId), groupEventIds.makeString(SEP))] 
  
  ( 
    groupEventIds,
    eTotalFee,
    allEventsActions ++ [IntegerEntry(kLastEventIndex, newLastEventIndex)]
  )
}

func isEventOpen(eventId: String) = {
  let eventStatus = getEventStatus(eventId)

  strict check = [ 
    eventStatus != E_NOT_FOUND || throwErr("event is not approved"),
    eventStatus != E_EXPIRED || throwErr("event is expired"),
    eventStatus != E_STOPPED || throwErr("event is stopped"),
    eventStatus != E_REJECTED || throwErr("event is rejected"),
    (eventStatus != E_CLOSED_NO && eventStatus != E_CLOSED_YES) || throwErr("event is closed")
  ]

  eventStatus == E_OPEN
}

@Callable(i)
func init(feeGetter: String, basePriceAsset: String, eventCreationFeeAmount: Int, groupCreationFeeAmount: Int, mintFeeRate: Int) = {
  strict check = [
    isAdmin(i.caller.toString()) || throwErr("init: permission denied")
  ]

  [
    StringEntry(kFeeGetter, feeGetter),
    StringEntry(kPredictionPriceAsset, basePriceAsset),
    IntegerEntry(kEventCreationFeeAmount, eventCreationFeeAmount),
    IntegerEntry(kGroupCreationFeeAmount, groupCreationFeeAmount),
    IntegerEntry(kEventMinFeeRate, mintFeeRate)
  ]
}

@Callable(i)
func mintTokens(eventId: Int) = {
  let sEventId = eventId.toString()

  strict check1 = [
    !forceStop || throwErr("contract is temporary stopped"),
    this.getString(kEventName(sEventId)).valueOrElse("").size() > 0 || throwErr("eventId is not found"),
    isEventOpen(sEventId) || throwErr("invalid event status"),
    i.payments.size() >= 2 || throwErr("must be with 2 payments"),
    i.payments[0].assetId == predictionPriceAsset || throwErr("wrong price asset"),
    i.payments[1].assetId == predictionPriceAsset || throwErr("wrong mint fee price asset")
  ]

  let paymentAmount = i.payments[0].amount
  let mintFeeAmount = i.payments[1].amount
  let mintAmount = priceAssetToAmountAsset(paymentAmount, PREDICTION_PRICE_UNIT)
  let minMintFeeAmount = fraction(paymentAmount, eventMintFeeRate, DEC8)

  strict check2 = [
    mintAmount > 0 || throwErr("payment is not enough"),
    mintFeeAmount >= minMintFeeAmount || throwErr(["mint fee amount is not enough (min: ", minMintFeeAmount.toString(), ")"].makeString(""))
  ]

  let transferMintFeeAction = if(minMintFeeAmount == 0) 
    then []
    else [ScriptTransfer(feeGetter, mintFeeAmount, i.payments[1].assetId)]

  let oldTotalMinted = this.getInteger(kEventTokensMinted(sEventId)).valueOrElse(0)
  let newTotalMinted = oldTotalMinted + mintAmount

  let yesAssetId = this.getStringValue(kEventYesAssetId(sEventId)).fromBase58String()
  let noAssetId = this.getStringValue(kEventNoAssetId(sEventId)).fromBase58String()
  
  let mintYesAction = Reissue(yesAssetId, mintAmount, true)
  let mintNoAction = Reissue(noAssetId, mintAmount, true)

  [
    mintYesAction,
    mintNoAction,
    ScriptTransfer(i.caller, mintAmount, yesAssetId),
    ScriptTransfer(i.caller, mintAmount, noAssetId),
    IntegerEntry(kEventTokensMinted(sEventId), newTotalMinted)
  ] ++ transferMintFeeAction
}

@Callable(i)
func mergeTokens(eventId: Int) = {
  let sEventId = eventId.toString()
  let yesAssetId = this.getStringValue(kEventYesAssetId(sEventId)).fromBase58String()
  let noAssetId = this.getStringValue(kEventNoAssetId(sEventId)).fromBase58String()

  let isAssetsRight = 
    (i.payments[0].assetId == yesAssetId && i.payments[1].assetId == noAssetId) ||
    (i.payments[0].assetId == noAssetId && i.payments[1].assetId == yesAssetId) 

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    i.payments.size() >= 2 || throwErr("must be with 2 payments"),
    isAssetsRight || throwErr("assets and event mismatch"),
    i.payments[0].amount == i.payments[1].amount || throwErr("payment amounts must be equal")
  ]  

  let sendAmount = amountAssetToPriceAsset(i.payments[0].amount, PREDICTION_PRICE_UNIT)
  let burnYesAction = Burn(yesAssetId, i.payments[0].amount)
  let burnNoAction = Burn(noAssetId, i.payments[0].amount)

  let oldTotalMinted = this.getInteger(kEventTokensMinted(sEventId)).valueOrElse(0)
  let newTotalMinted = oldTotalMinted - i.payments[0].amount

  [
    ScriptTransfer(i.caller, sendAmount, predictionPriceAsset),
    IntegerEntry(kEventTokensMinted(sEventId), newTotalMinted),
    burnYesAction,
    burnNoAction
  ]
}

@Callable(i)
func withdrawTokens(eventId: Int) = {
  let sEventId = eventId.toString()
  let eventStatus = getEventStatus(sEventId)

  let finalEventAssetId = if (eventStatus == E_CLOSED_YES)
    then this.getStringValue(kEventYesAssetId(sEventId)).fromBase58String()
    else if eventStatus == E_CLOSED_NO
      then this.getStringValue(kEventNoAssetId(sEventId)).fromBase58String()
      else throwErr("invalid event status")

  strict check = [
    eventStatus == E_CLOSED_YES || eventStatus == E_CLOSED_NO || throwErr("event is not closed"),
    i.payments.size() >= 1 || throwErr("must be with payment"),
    i.payments[0].assetId == finalEventAssetId || throwErr("invalid asset in payment")
  ]

  let priceAssetAmount = i.payments[0].amount * PREDICTION_PRICE_UNIT

  [
    ScriptTransfer(i.caller, priceAssetAmount, predictionPriceAsset),
    Burn(finalEventAssetId, i.payments[0].amount)
  ]
}

@Callable(i)
func setEventStatus(eventId: Int, status: Int, category: String) = {
  let sEventId = eventId.toString()
  let groupId = this.getString(kEventGroupId(sEventId)).valueOrErrorMessage(wrapErr("invalid group id in event"))

  let oldRejectedCount = getRejectedCount(groupId)
  let oldEventStatus = getEventStatus(sEventId)
  let groupActions = editGroupHelper(groupId, "", "", category, "", "", "")
  let groupRejectedActions = if (oldEventStatus == E_REJECTED)
    then {
      if (status != E_REJECTED) 
      then [IntegerEntry(kGroupRejectedCount(groupId), oldRejectedCount - 1)]
      else []
    }
    else {
      if (status == E_REJECTED) 
      then [IntegerEntry(kGroupRejectedCount(groupId), oldRejectedCount + 1)]
      else []
    }
  strict check = [
    isEventAdmin(i.caller.toString()) || throwErr("setEventStatus: permission denied"),
    this.getString(kEventName(sEventId)).valueOrErrorMessage(wrapErr("eventId is not found"))
  ]

  [ IntegerEntry(kEventStatus(sEventId), status) ] ++ 
  groupActions ++
  groupRejectedActions
}

@Callable(i)
func addEventAdmin(address: String) = {
  strict check = [
    isAdmin(i.caller.toString()) || throwErr("addEventAdmin: permission denied")
  ]

  let newAdminList = eventAdminList :+ address
  let sNewAdminList = newAdminList.makeString(SEP)

  [
    StringEntry(kEventAdminList, sNewAdminList)
  ]
}

@Callable(i)
func removeEventAdmin(address: String) = {
  strict check = [
    isAdmin(i.caller.toString()) || throwErr("removeEventAdmin: permission denied")
  ]

  let newAdminList = match (eventAdminList.indexOf(address)) {
      case ind:Int => eventAdminList.removeByIndex(ind)
      case _ => eventAdminList
    }
  
  let resultAction = if(newAdminList.size() > 0) 
    then StringEntry(kEventAdminList, newAdminList.makeString(SEP))
    else DeleteEntry(kEventAdminList)

  [
    resultAction
  ]
}

@Callable(i)
func editGroup(groupId: Int, name: String, description: String, category: String, imgSrc: String, source: String, creator: String) = {
  let sGroupId = groupId.toString()
  strict check = [
    isEventAdmin(i.caller.toString()) || throwErr("editGroup: permission denied"),
    this.getString(kGroupName(sGroupId)).valueOrErrorMessage(wrapErr("groupId is not found"))
  ]

  editGroupHelper(sGroupId, name, description, category, imgSrc, source, creator)
}

@Callable(i)
func editEvent(eventId: Int, groupId: Int, name: String, endDatetime: Int, creator: String) = {
  let sEventId = eventId.toString()
  let sGroupId = if (groupId > 0) then groupId.toString() else ""
  strict check = [
    isEventAdmin(i.caller.toString()) || throwErr("editEvent: permission denied"),
    this.getString(kEventName(sEventId)).valueOrErrorMessage(wrapErr("eventId is not found"))
  ]
  
  editEventHelper(sEventId, sGroupId, name, endDatetime, creator)
}

@Callable(i)
func newGroupAndEvents(
  gName        : String,
  gDescription : String,
  gImgSrc      : String,
  gSource      : String,
  eNames       : String,
  eEndDatetimes: String
) = {
  let newGroupIndex = lastGroupIndex + 1
  let groupId = newGroupIndex.toString()

  let creator = i.caller.toString()
  let groupActions = editGroupHelper(groupId, gName, gDescription, "", gImgSrc, gSource, creator) ++ 
    [IntegerEntry(kLastGroupIndex, newGroupIndex)]

  let (groupEventIds, eTotalFee, eventsActions) = massNewEventsHelper(creator, groupId, eNames, eEndDatetimes)
  let totalFee = groupCreationFeeAmount + eTotalFee

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    gName.size() > 0 || throwErr("group name is required"),
    gDescription.size() > 0 || throwErr("group description is required"),
    gImgSrc.size() > 0 || throwErr("group image source is required"),
    gSource.size() > 0 || throwErr("group source is required"),
    totalFee == 0 || i.payments.size() > 0 || throwErr("payment not found"),
    totalFee == 0 || i.payments[0].assetId == predictionPriceAsset || throwErr("wrong creation fee asset"),
    totalFee == 0 || i.payments[0].amount >= totalFee || throwErr(["not enough creation fee amount", "need:", totalFee.toString()].makeString(" "))
  ]

  let groupEventIdsActions = [StringEntry(kGroupEvents(groupId), groupEventIds.makeString(SEP))] 
  let transferFeeAction = if(totalFee == 0) 
    then []
    else [ScriptTransfer(feeGetter, i.payments[0].amount, i.payments[0].assetId)]

  groupActions ++
  groupEventIdsActions ++
  eventsActions ++
  transferFeeAction
}

@Callable(i)
func newEvents(
  groupId      : Int,
  eNames       : String,
  eEndDatetimes: String
) = {
  let sGroupId = groupId.toString()
  let creator = i.caller.toString()

  let (newGroupEventIds, totalFee, eventsActions) = massNewEventsHelper(creator, sGroupId, eNames, eEndDatetimes)

  strict check = [
    !forceStop || throwErr("contract is temporary stopped"),
    totalFee == 0 || i.payments.size() > 0 || throwErr("payment not found"),
    totalFee == 0 || i.payments[0].assetId == predictionPriceAsset || throwErr("wrong creation fee asset"),
    totalFee == 0 || i.payments[0].amount >= totalFee || throwErr(["not enough creation fee amount", "need:", totalFee.toString()].makeString(" "))
  ]

  let oldGroupEventIds = getGroupEvents(sGroupId)
  let groupNewTotalEventsCount = oldGroupEventIds.size() + newGroupEventIds.size()
  let groupRejectedEventsCount = getRejectedCount(sGroupId)
  let groupEventIdsActions = if (groupNewTotalEventsCount - groupRejectedEventsCount <= MAX_GROUP_EVENTS) 
    then [StringEntry(kGroupEvents(sGroupId), (oldGroupEventIds ++ newGroupEventIds).makeString(SEP))]
    else throwErr(["max", MAX_GROUP_EVENTS.toString(), "events in group"].makeString(" "))

  let transferFeeAction = if(totalFee == 0) 
    then []
    else [ScriptTransfer(feeGetter, i.payments[0].amount, i.payments[0].assetId)]

  groupEventIdsActions ++
  eventsActions ++
  transferFeeAction
}

@Verifier(tx)
func verify() = {
  let targetPublicKey = match managerPublicKeyOrUnit() {
    case pk: ByteVector => pk
    case _: Unit => tx.senderPublicKey
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], targetPublicKey)
}
