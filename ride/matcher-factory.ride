{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "matcher-factory.ride"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

let kForceStop        = ["%s", "forceStop"].makeString(SEP)
let kMatcherPublicKey = ["%s", "matcherPublicKey"].makeString(SEP)
let kValidatorAddress = ["%s", "validatorAddress"].makeString(SEP)
let kTreasuryAddress  = ["%s", "treasuryAddress"].makeString(SEP)
let kPoolAddress      = ["%s", "poolAddress"].makeString(SEP)
let kSpotAddress      = ["%s", "spotAddress"].makeString(SEP)
let kLeverageAddress  = ["%s", "leverageAddress"].makeString(SEP)
let kWithdrawDelay    = ["%s", "withdrawDelay"].makeString(SEP)

let kAllowedAssets = ["%s", "allowedAssets"].makeString(SEP)
let allowedAssets  = match (this.getString(kAllowedAssets)) {
    case s:String => s.split_4C(SEP)
    case _ => []
  }

let kLeverageValue = ["%s", "maxLeverageValue"].makeString(SEP)
let maxLeverageValue  = this.getInteger(kLeverageValue).valueOrElse(1)

func kUserLeverage(user: String) = ["%s%s", "leverage", user].makeString(SEP)

let contractsList = [
    this.getString(kSpotAddress).valueOrElse(""),     # spot
    this.getString(kLeverageAddress).valueOrElse(""), # leverage
    ""                                                # margin
  ]

func setLeverageHelper(user: String, leverage: Int) = {
  strict check = [
    leverage > 0 || throwErr("leverage value must be greater than 0")
  ]

  [
    IntegerEntry(kUserLeverage(user), leverage)
  ]
}

@Callable(i)
func init(
    matcherPublicKey : String,
    validatorContract: String,
    treasuryContract : String,
    poolContract     : String,
    spotContract     : String,
    leverageContract : String
  ) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  let pubKey    = if (matcherPublicKey  == "") then [] else [StringEntry(kMatcherPublicKey, matcherPublicKey)]
  let validator = if (validatorContract == "") then [] else [StringEntry(kValidatorAddress, validatorContract)]
  let treasury  = if (treasuryContract  == "") then [] else [StringEntry(kTreasuryAddress, treasuryContract)]
  let pool      = if (poolContract      == "") then [] else [StringEntry(kPoolAddress, poolContract)]
  let spot      = if (spotContract      == "") then [] else [StringEntry(kSpotAddress, spotContract)]
  let leverage  = if (leverageContract  == "") then [] else [StringEntry(kLeverageAddress, leverageContract)]

  validator ++ pubKey ++ spot ++ treasury ++ pool ++ leverage
}

@Callable(i)
func forceStop(value: Boolean) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]
    
  [ BooleanEntry(kForceStop, value) ]
}

@Callable(i)
func getOrderTypeContract(orderType: Int) = {
  ([], contractsList[orderType])
}

@Callable(i)
func getAllOrderTypeContracts() = {
  ([], contractsList)
}

@Callable(i)
func addAllowedAsset(assetId: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  let newAllowedList = allowedAssets :+ assetId

  [
    StringEntry(kAllowedAssets, newAllowedList.makeString(SEP))
  ]
}

@Callable(i)
func removeAllowedAsset(assetId: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  match (allowedAssets.indexOf(assetId)) {
      case index:Int => {
        let newAllowedList = allowedAssets.removeByIndex(index)
        if (newAllowedList.size() > 0) 
          then [StringEntry(kAllowedAssets, newAllowedList.makeString(SEP))]
          else [DeleteEntry(kAllowedAssets)]
      }
      case _ => throw("asset is not found")
    }
}

@Callable(i)
func setLeverage(leverage: Int) = {
  strict check = [
    leverage <= maxLeverageValue || ["max leverage is ", maxLeverageValue.toString()].makeString(" ").throwErr()
  ]

  setLeverageHelper(i.caller.toString(), leverage)
}

@Callable(i)
func setLeverageFor(user: String, leverage: Int) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  setLeverageHelper(user, leverage)
}

@Callable(i)
func setMaxLeverage(maxLeverage: Int) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [
    IntegerEntry(kLeverageValue, maxLeverage)
  ]
}

@Callable(i)
func setWithdrawDelay(delay: Int) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [
    IntegerEntry(kWithdrawDelay, delay)
  ]
}