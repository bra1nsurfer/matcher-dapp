{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let CONTRACT_NAME = "matcher-factory.ride"

func wrapErr(s: String) = {
  CONTRACT_NAME + ": " + s
}

func throwErr(s: String) = {
  throw(wrapErr(s))
}

let kForceStop                  = ["%s", "forceStop"].makeString(SEP)
let kMatcherPublicKey           = ["%s", "matcherPublicKey"].makeString(SEP)
let kValidatorAddress           = ["%s", "validatorAddress"].makeString(SEP)
let kPredictionValidatorAddress = ["%s", "predictionValidatorAddress"].makeString(SEP)
let kTreasuryAddress            = ["%s", "treasuryAddress"].makeString(SEP)
let kPoolAddress                = ["%s", "poolAddress"].makeString(SEP)
let kSpotAddress                = ["%s", "spotAddress"].makeString(SEP)
let kLeverageAddress            = ["%s", "leverageAddress"].makeString(SEP)
let kMarginAddress              = ["%s", "marginAddress"].makeString(SEP)
let kPredictionAddress          = ["%s", "predictionAddress"].makeString(SEP)
let kWithdrawDelay              = ["%s", "withdrawDelay"].makeString(SEP)

let kAllowedAssets = ["%s", "allowedAssets"].makeString(SEP)
let allowedAssets  = match (this.getString(kAllowedAssets)) {
    case s:String => s.split_4C(SEP)
    case _ => []
  }

let kLeverageValue = ["%s", "maxLeverageValue"].makeString(SEP)
let maxLeverageValue  = this.getInteger(kLeverageValue).valueOrElse(1)

func kUserLeverage(user: String) = ["%s%s", "leverage", user].makeString(SEP)

let orderTypeContractsList = [
    this.getString(kSpotAddress).valueOrElse(""),      # spot
    this.getString(kLeverageAddress).valueOrElse(""),  # leverage
    this.getString(kMarginAddress).valueOrElse(""),    # margin
    this.getString(kPredictionAddress).valueOrElse("") # prediction
  ]

func setLeverageHelper(user: String, leverage: Int) = {
  strict check = [
    leverage > 0 || throwErr("leverage value must be greater than 0")
  ]

  [
    IntegerEntry(kUserLeverage(user), leverage)
  ]
}

@Callable(i)
func init(
    matcherPublicKey          : String,
    validatorAddress          : String,
    predictionValidatorAddress: String,
    treasuryAddress           : String,
    poolAddress               : String,
    spotAddress               : String,
    leverageAddress           : String,
    marginAddress             : String,
    predictionAddress         : String
  ) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  let pubKey              = if (matcherPublicKey           == "") then [] else [StringEntry(kMatcherPublicKey, matcherPublicKey)]
  let validator           = if (validatorAddress           == "") then [] else [StringEntry(kValidatorAddress, validatorAddress)]
  let predictionValidator = if (predictionValidatorAddress == "") then [] else [StringEntry(kPredictionValidatorAddress, predictionValidatorAddress)]
  let treasury            = if (treasuryAddress            == "") then [] else [StringEntry(kTreasuryAddress, treasuryAddress)]
  let pool                = if (poolAddress                == "") then [] else [StringEntry(kPoolAddress, poolAddress)]
  let spot                = if (spotAddress                == "") then [] else [StringEntry(kSpotAddress, spotAddress)]
  let leverage            = if (leverageAddress            == "") then [] else [StringEntry(kLeverageAddress, leverageAddress)]
  let margin              = if (marginAddress              == "") then [] else [StringEntry(kMarginAddress, marginAddress)]
  let prediction          = if (predictionAddress          == "") then [] else [StringEntry(kPredictionAddress, predictionAddress)]

  pubKey ++ 
  validator ++ 
  predictionValidator ++ 
  spot ++ 
  treasury ++ 
  pool ++ 
  leverage ++ 
  margin ++ 
  prediction
}

@Callable(i)
func forceStop(value: Boolean) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]
    
  [ BooleanEntry(kForceStop, value) ]
}

@Callable(i)
func getOrderTypeContract(orderType: Int) = {
  ([], orderTypeContractsList[orderType])
}

@Callable(i)
func getAllOrderTypeContracts() = {
  ([], orderTypeContractsList)
}

@Callable(i)
func addAllowedAsset(assetId: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  let newAllowedList = allowedAssets :+ assetId

  [
    StringEntry(kAllowedAssets, newAllowedList.makeString(SEP))
  ]
}

@Callable(i)
func removeAllowedAsset(assetId: String) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  match (allowedAssets.indexOf(assetId)) {
      case index:Int => {
        let newAllowedList = allowedAssets.removeByIndex(index)
        if (newAllowedList.size() > 0) 
          then [StringEntry(kAllowedAssets, newAllowedList.makeString(SEP))]
          else [DeleteEntry(kAllowedAssets)]
      }
      case _ => throw("asset is not found")
    }
}

@Callable(i)
func setLeverage(leverage: Int) = {
  strict check = [
    leverage <= maxLeverageValue || ["max leverage is ", maxLeverageValue.toString()].makeString(" ").throwErr()
  ]

  setLeverageHelper(i.caller.toString(), leverage)
}

@Callable(i)
func setLeverageFor(user: String, leverage: Int) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  setLeverageHelper(user, leverage)
}

@Callable(i)
func setMaxLeverage(maxLeverage: Int) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [
    IntegerEntry(kLeverageValue, maxLeverage)
  ]
}

@Callable(i)
func setWithdrawDelay(delay: Int) = {
  strict check = [
    i.caller == this || throwErr("permission denied")
  ]

  [
    IntegerEntry(kWithdrawDelay, delay)
  ]
}